{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#index","title":"Index","text":"<ul> <li>InTrade-package \u2014 Package description</li> </ul> <p>1- Data Loading Functions</p> <ul> <li>load_Test \u2014 Load test/example datasets</li> <li>load_ADB \u2014 Load Asian Development Bank (ADB) MRIO data</li> <li>load_EORA \u2014 Load Eora26 MRIO data</li> <li>load_FIGARO \u2014 Load FIGARO input\u2013output tables</li> <li>load_GLORIA \u2014 Load GLORIA MRIO data</li> <li>load_TIVA \u2014 Load OECD TiVA (Trade in Value Added) data</li> <li>load_WIOD \u2014 Load WIOD (World Input\u2013Output Database) data</li> <li>aggregate \u2014 Country level aggregation</li> </ul> <p>2- Create Objects Functions</p> <ul> <li>obj_IO \u2014 Create input\u2013output object</li> <li>obj_Grav \u2014 Create gravity object</li> <li>obj_Grav_panel \u2014 Create gravity panel object (multi-year)</li> </ul> <p>3.A- Input - Output Analysis Functions</p> <ul> <li>KWW \u2014 Aggregate WWZ terms into Koopman\u2013Wang\u2013Wei components</li> <li>WWZ \u2014 Wang\u2013Wei\u2013Zhu value-added trade decomposition</li> <li>BM \u2014 Borin-Mancini VA export decomposition from WIO dict</li> <li>BMT_trade \u2014 Borin-Mancini-Taglioni trade participation decomposition</li> <li>BMT_output \u2014 Borin-Mancini-Taglioni output participation decomposition</li> <li>stream \u2014 Compute upstream/downstream indices by country\u2013sector</li> </ul> <p>3.B- Gravity Analysis Functions</p> <ul> <li>struc_grav_cf \u2014 Core structural gravity + exact-hat counterfactual engine</li> <li>struc_grav_incre \u2014 Structural gravity counterfactual: trade cost increase</li> <li>struc_grav_asif \u2014 Structural gravity counterfactual: \u201cas-if\u201d FTA scenario</li> <li>struc_grav_inout \u2014 Structural gravity counterfactual: entry/exit in RTA</li> <li>grav_panel \u2014 Panel gravity PPML with flexible fixed effects</li> <li>solve_system_Ti \u2014 Equilibrium system for exact-hat algebra (used by <code>struc_grav_cf</code>)</li> </ul>"},{"location":"BM/","title":"BM","text":""},{"location":"BM/#bm","title":"BM","text":"<p>Description</p> <p>Borin &amp; Mancini (2023) VA export decomposition from a WIO dictionary. <code>BM</code> computes a Borin &amp; Mancini (2023) decomposition of exports into Domestic Value Added (DVA), Foreign Value Added (FVA), and detailed intermediate channels, starting from a WIO dictionary built from an MRIO table.</p> <p>It reproduces, in Python, the logic of an MRIO-based decomposition as in Borin &amp; Mancini (2023), but using the matrix objects already contained in <code>wio</code>.</p> <p>Usage</p> <p><code>BM(wio)</code></p> <p>Arguments</p> <ul> <li><code>wio</code> (dict): A dictionary containing the main input\u2013output matrices and vectors, with keys:</li> </ul> <p>Matrices (shape CS \u00d7 CS unless stated otherwise):</p> <ul> <li><code>\"Z\"</code>, <code>\"Zd\"</code>, <code>\"Zm\"</code>: intermediate input matrices</li> <li><code>\"A\"</code>, <code>\"Ad\"</code>, <code>\"Am\"</code>: technical coefficient matrices</li> <li><code>\"B\"</code>, <code>\"Bd\"</code>, <code>\"Bm\"</code>: Leontief inverse matrices</li> <li><code>\"Ld\"</code>: local (domestic) Leontief inverse</li> <li><code>\"Yfd\"</code>: final demand with components (CS \u00d7 CFD)</li> <li><code>\"Y\"</code>, <code>\"Yd\"</code>, <code>\"Ym\"</code>: final demand (total / domestic / foreign), shape CS \u00d7 C</li> <li><code>\"W\"</code>: diagonalised value-added coefficients matrix (CS \u00d7 CS)</li> <li><code>\"E\"</code>: diagonalised gross exports (CS \u00d7 CS)</li> </ul> <p>Vectors:</p> <ul> <li><code>\"VA\"</code>: value added (CS \u00d7 1)</li> <li><code>\"V\"</code>: value added coefficients (CS \u00d7 1)</li> <li><code>\"X\"</code>: gross output (CS \u00d7 1)</li> <li><code>\"EXGR\"</code>: gross bilateral exports (CS \u00d7 C)</li> </ul> <p>Meta information:</p> <ul> <li><code>\"dims\"</code>: dictionary with at least <code>\"C\"</code>, <code>\"S\"</code>, <code>\"CS\"</code></li> <li><code>\"names\"</code>: dictionary with country and sector labels</li> </ul> <p>Details</p> <p>The function:</p> <ol> <li>Extracts <code>C</code>, <code>S</code>, <code>CS</code> from <code>wio[\"dims\"]</code>.</li> <li>Wraps key matrices (<code>Z</code>, <code>A</code>, <code>B</code>, <code>Y</code>) into a lightweight class to operate with country-level sub-blocks (or uses plain numpy arrays with equivalent logic).</li> <li>Reconstructs the Borin &amp; Mancini (2023) decomposition of exports into:</li> <li><code>DAVAX1</code>, <code>DAVAX2</code>: domestic VA embodied in gross exports, different channels.</li> <li><code>REX1</code>, <code>REX2</code>, <code>REX3</code>, <code>REF1</code>, <code>REF2</code>: re-export and re-import channels.</li> <li><code>FVA</code>: foreign value added in exports.</li> <li><code>PDC1</code>, <code>PDC2</code>: (partial) double counting components.</li> <li>Returns two DataFrames:</li> <li><code>ed_es</code>: decomposition by exporting sectors.</li> <li><code>ed_os</code>: decomposition by origin sectors.</li> </ol> <p>Each DataFrame contains columns for each exporter <code>s</code>, importer <code>r</code>, and sector <code>i</code>:</p> <ul> <li><code>s</code>: exporter country index</li> <li><code>r</code>: partner country index ($\\neq$ s)</li> <li><code>breakdown</code>: \"es\" or \"os\"</li> <li><code>i</code>: sector index of the exporter (or origin)</li> <li><code>exports</code>: gross exports for that triplet</li> <li><code>davax1</code>, <code>davax2</code>, <code>rex1</code>, <code>rex2</code>, <code>rex3</code>, <code>ref1</code>, <code>ref2</code>, <code>fva</code>, <code>pdc1</code>, <code>pdc2</code>: decomposition components</li> </ul> <p>Value</p> <ul> <li><code>ed_es</code> (pandas.DataFrame): Decomposition by exporting sectors.</li> <li><code>ed_os</code> (pandas.DataFrame): Decomposition by origin sectors.</li> </ul> <p>Each row corresponds to a (exporter, importer, sector) combination and contains a detailed decomposition of gross exports.</p> <p>Example</p> <pre><code>from intrade import BM, build_wio_from_raw  # hypothetical\n\nwio = build_wio_from_raw(Z, Y, VA, country_names, sector_names)\ned_es, ed_os = BM(wio)\n\n# Aggregate DVA and FVA by exporter\ndva_by_exp = ed_es.groupby(\"s\")[[\"davax1\", \"davax2\"]].sum()\nfva_by_exp = ed_es.groupby(\"s\")[[\"fva\"]].sum()\n</code></pre>"},{"location":"COF/","title":"2- Create Objects Functions","text":""},{"location":"COF/#2-create-objects-functions","title":"2- Create Objects Functions","text":"<p>Usage and arguments</p> <p>obj_TYPE(dic)</p> <ul> <li>TYPE: IO or Grav- year: year</li> <li>dic: diccionary created with load_XXX() functions</li> </ul>"},{"location":"DLF/","title":"1- Data Loading Functions","text":""},{"location":"DLF/#1-data-loading-functions","title":"1- Data Loading Functions","text":"<p>Usage and arguments</p> <p>load_NAME IO(dire,year,typ)</p> <ul> <li>dire: directory where the data is stored</li> <li>year: year</li> <li>typ: dataset</li> </ul> Func. WEB Year Type Coun. Sect. load_ADB Data 2000, 200-2022 current 62 62 35 2017-2022 current 72 72 35 2007, 2011 &amp; 2017 current 71 LAC 73 35 load_EORA Data 1990-2017 (18-23 pay) basic prices 189 26 1990-2017 (18-23 pay) purchase prices 189 26 load_FIGARO Data (2025ed.) 2010-2022 Industry/Product 46 64 load_GLORIA Data 1990-2028 164 120 load_TIVA Data 1995-2020 extended/small 77 45 load_WIOD Data 2000-2014 Release 2016 43 56"},{"location":"GAF/","title":"3.B- Gravity Analysis Functions","text":""},{"location":"GAF/#3b-gravity-analysis-functions","title":"3.B- Gravity Analysis Functions","text":"<p>Usage and arguments</p> <p>NAME(obj_Grav, param)</p> <ul> <li>NAME: Kind of analysis.</li> <li>obj_Grav: object created with obj_Grav function.</li> <li>param: specific parameters for each function.</li> </ul>"},{"location":"IOAF/","title":"3.A- Input Output Analysis Functions","text":""},{"location":"IOAF/#3a-input-output-analysis-functions","title":"3.A- Input Output Analysis Functions","text":"<p>Usage and arguments</p> <p>NAME(obj_IO)</p> <ul> <li>TYPE: Capital letters of authors.</li> <li>obj_IO: object created with obj_IO function</li> </ul>"},{"location":"KWW/","title":"KWW","text":""},{"location":"KWW/#kww","title":"KWW","text":"<p>Description</p> <p>Aggregates the detailed Wang\u2013Wei\u2013Zhu (WWZ) decomposition into a smaller set of Koopman\u2013Wang\u2013Wei (KWW)-style components.</p> <p>Starting from the 16 WWZ terms produced by WWZ(io, agg), this function groups them into 9 economically meaningful categories plus a total, either in levels (same units as gross exports) or as percentage shares of total exports for each flow.</p> <p>Usage</p> <p><code>KWW(io, agg =\"\", shares: bool = False)</code></p> <p>Arguments</p> <p>io (dict) World input\u2013output object to be passed to WWZ. It must be compatible with your WWZ function, i.e. WWZ(io, agg) returns a pandas.DataFrame whose columns are the 16 WWZ components:</p> <p>[\"DVA_FIN\", \"DVA_INT\", \"DVA_INTrex1\", \"DVA_INTrex2\", \"DVA_INTrex3\", \"RDV_FIN1\", \"RDV_FIN2\", \"RDV_INT\", \"DDC_FIN\", \"DDC_INT\", \"MVA_FIN\", \"OVA_FIN\", \"MVA_INT\", \"OVA_INT\", \"MDC\", \"ODC\"].</p> <p>agg (str, optional, default \"\") Optional aggregation level passed directly to WWZ(io, agg). It controls at which level the KWW components are reported:</p> <ul> <li>\"\" (default): origin country\u2013sector \u00d7 destination country.</li> <li>\"ORI\": by origin country.</li> <li>\"DES\": by destination country.</li> <li>\"SEC\": by origin sector.</li> <li>\"ORI-SEC\": by origin country\u2013sector pair.</li> </ul> <p>The exact meaning of agg is the same as in WWZ.</p> <p>shares (bool, optional, default False)</p> <ul> <li>If False: the function returns levels \u2013 the KWW components in the same units as the underlying WWZ decomposition (typically monetary units).</li> <li>If True: the function returns shares in percent of each KWW component in total gross exports for each observation. In this case, the Tot column will be exactly 100 for every row.</li> </ul> <p>Details</p> <p>The function first calls:</p> <p>WWZ_c = WWZ(io, agg)</p> <p>to obtain the full WWZ decomposition, with rows representing origin\u2013destination flows (or their aggregates, depending on agg) and columns representing the 16 WWZ terms.</p> <p>It then maps the 16 WWZ components into the KWW-style groups using the following mapping:</p> <p>Domestic value added:</p> <ul> <li>\"DVA_FIN\" \u2192 \"DVA_FIN\"   Domestic VA in final goods exports.</li> <li>\"DVA_INT\" \u2192 \"DVA_INT\"   Domestic VA in intermediate exports absorbed by the direct importer.</li> <li>\"DVA_INTrex1\" \u2192 \"DVA_INT\"   DVA in intermediates via direct importer to 3rd-country domestic use.</li> <li>\"DVA_INTrex2\" \u2192 \"DVA_INTrex\"   DVA in intermediates via direct importer to 3rd-country final exports.</li> <li>\"DVA_INTrex3\" \u2192 \"DVA_INTrex\"   DVA in intermediates via direct importer to 3rd-country intermediates.</li> </ul> <p>Returned domestic value added:</p> <ul> <li>\"RDV_FIN1\" \u2192 \"RDV_FIN\"   Returned DVA in final imports from the direct importer.</li> <li>\"RDV_FIN2\" \u2192 \"RDV_FIN\"   Returned DVA in final imports via third countries.</li> <li>\"RDV_INT\" \u2192 \"RDV_INT\"   Returned DVA in intermediate imports used domestically.</li> </ul> <p>Double-counted domestic content:</p> <ul> <li>\"DDC_FIN\" \u2192 \"DDC\"   Double-counted DVA in final exports.</li> <li>\"DDC_INT\" \u2192 \"DDC\"   Double-counted DVA in intermediate exports.</li> </ul> <p>Foreign value added:</p> <ul> <li>\"MVA_FIN\" \u2192 \"FVA_FIN\"   Foreign VA in final goods exports (direct importer).</li> <li>\"OVA_FIN\" \u2192 \"FVA_FIN\"   \u201cOther countries\u2019\u201d VA in final goods exports (via third countries).</li> <li>\"MVA_INT\" \u2192 \"FVA_INT\"   Foreign VA in intermediate exports (direct importer).</li> <li>\"OVA_INT\" \u2192 \"FVA_INT\"   \u201cOther countries\u2019\u201d VA in intermediate exports.</li> </ul> <p>Foreign double counting:</p> <ul> <li>\"MDC\" \u2192 \"FDC\"   Multilateral double-counting.</li> <li>\"ODC\" \u2192 \"FDC\"</li> </ul> <p>Other double-counting.</p> <p>The 16 WWZ columns are grouped according to this mapping and summed, yielding 9 KWW-style components. The function then adds:</p> <p>\"Tot\": the row-wise sum of all KWW components:</p> <ul> <li>If shares=False: Tot equals total gross exports (in levels).</li> <li>If shares=True: the KWW components are divided by Tot and multiplied by 100, so Tot = 100 for each row.</li> </ul> <p>The final DataFrame keeps the same index as WWZ(io, agg) (e.g. origin\u2013sector\u2013destination or any aggregated level chosen via agg), but with fewer, more interpretable columns.</p> <p>Returns</p> <p>KWW_c (pandas.DataFrame)</p> <p>DataFrame with the same index as WWZ(io, agg) and the following columns, in this order:</p> <ul> <li> <p>\"DVA_FIN\"   Domestic value added in final goods exports.</p> </li> <li> <p>\"DVA_INT\"   Domestic value added in intermediate exports absorbed by the direct importer, including DVA_INT and DVA_INTrex1.</p> </li> <li> <p>\"DVA_INTrex\"   Domestic value added in intermediate exports that are re-exported (third-country use), combining DVA_INTrex2 and DVA_INTrex3.</p> </li> <li> <p>\"RDV_FIN\"   Returned domestic value added in final goods.</p> </li> <li> <p>\"RDV_INT\"   Returned domestic value added in intermediates.</p> </li> <li> <p>\"DDC\"   Double-counted domestic content (from DDC_FIN and DDC_INT).</p> </li> <li> <p>\"FVA_FIN\"   Foreign value added in final goods exports (direct and via other countries).</p> </li> <li> <p>\"FVA_INT\"   Foreign value added in intermediate exports.</p> </li> <li> <p>\"FDC\"   Foreign-related double-counting (multilateral and other).</p> </li> <li> <p>\"Tot\"</p> </li> </ul> <p>Total over all KWW components:</p> <ul> <li> <p>If shares=False: total gross exports (levels).</p> </li> <li> <p>If shares=True: Tot = 100 for every row (percent shares).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_TIVA, obj_IO, KWW\n\n# 1. Load data and build IO object\ntiva_dic = load_TIVA(dire=\"/path/to/ICIO/\", year=2015, typ=\"extended\")\nwio = obj_IO(tiva_dic)\n\n# 2. KWW-style decomposition at origin country\u2013sector \u00d7 destination country level (levels)\nkww_levels = KWW(wio, agg=\"\", shares=False)\n\n# 3. KWW-style decomposition aggregated by origin country (shares)\nkww_origin_shares = KWW(wio, agg=\"ORI\", shares=True)\n\n# 4. Inspect domestic vs foreign content in gross exports\nkww_levels[[\"DVA_FIN\", \"DVA_INT\", \"FVA_FIN\", \"FVA_INT\"]].head()\n</code></pre>"},{"location":"WWZ/","title":"WWZ","text":""},{"location":"WWZ/#wwz","title":"WWZ","text":"<p>Description</p> <p>Computes the Wang\u2013Wei\u2013Zhu (2013) value-added trade decomposition from a harmonised input\u2013output object. Given an IO object created by obj_IO, this function decomposes gross exports into 16 value-added and double-counting components at the origin country\u2013sector \u00d7 destination country level, with optional aggregation by origin, destination, or sector.</p> <p>Usage</p> <p><code>WWZ(wio, agg: str = \"\")</code></p> <p>Arguments</p> <p>wio (dict)   IO object as returned by obj_IO, containing at least:</p> <ul> <li>wio[\"Z\"], wio[\"Zd\"], wio[\"Zm\"]: intermediate inputs (total / domestic / foreign)</li> <li>wio[\"A\"], wio[\"Ad\"], wio[\"Am\"]: technical coefficients (total / domestic / foreign)</li> <li>wio[\"B\"], wio[\"Bd\"], wio[\"Bm\"]: Leontief inverse (total / domestic / foreign)</li> <li>wio[\"Y\"], wio[\"Yd\"], wio[\"Ym\"]: final demand (total / domestic / foreign)</li> <li>wio[\"L\"]: local (domestic) Leontief inverse</li> <li>wio[\"Yfd\"]: full final demand by country\u2013component</li> <li>wio[\"VA\"], wio[\"V\"], wio[\"W\"]: value added in levels, VA coefficients, and diagonal VA matrix</li> <li>wio[\"X\"], wio[\"EXGR\"], wio[\"E\"]: gross output, gross bilateral exports, and diagonal total exports</li> <li>wio[\"dims\"]: dictionary with dimensions {\"C\",\"S\",\"FD\",\"CS\",\"CFD\"}</li> <li>wio[\"names\"]: dictionary with name vectors (\"c_names\", \"s_names\", \"fd_names\", \"cs_names\", \"cfd_names\")</li> </ul> <p>agg (str, optional)</p> <p>Aggregation level for the decomposition. One of:</p> <ul> <li>\"\" (default): no aggregation. Output is at   origin country\u2013sector \u00d7 destination country level, with index   \"\". <li>\"ORI\": aggregate all components by origin country.   Index becomes 3-letter ISO origin country codes.</li> <li>\"DES\": aggregate all components by destination country.   Index becomes 3-letter ISO destination country codes.</li> <li>\"SEC\": aggregate all components by origin sector across all countries and destinations.   Index becomes the sector identifier (middle token in the original index).</li> <li>\"ORI-SEC\": aggregate by origin country\u2013sector (collapsing destination).   Index becomes \"_\". <p>Details</p> <p>The function implements the Wang\u2013Wei\u2013Zhu (2018) decomposition of gross exports into 16 components that distinguish:</p> <ul> <li>Domestic value added in exports of final and intermediate goods,</li> <li>Domestic value added that returns home (RDV),</li> <li>Double-counted domestic value added (DDC),</li> <li>Foreign and \u201cother\u201d countries\u2019 value added in exports (MVA, OVA),</li> <li>Multilateral and other double-counting terms.</li> </ul> <p>Internally, WWZ:</p> <p>1- Checks that all required matrices and metadata are present in wio and that CS = C \u00d7 S.</p> <p>2- Constructs country\u2013sector block masks to separate domestic vs foreign flows.</p> <p>3- Computes the 16 WWZ components using combinations of:</p> <ul> <li>domestic and foreign parts of the Leontief inverse,</li> <li>domestic and foreign technical coefficients,</li> <li>domestic and foreign final demand,</li> <li>value-added coefficients and gross output.</li> </ul> <p>4- Stores all components in a 3-dimensional array (origin country\u2013sector, destination country, 16 components).</p> <p>5- Converts this array into a labeled DataFrame with one row per origin country\u2013sector \u00d7 destination country combination.</p> <p>6- Optionally aggregates over origin countries, destination countries, sectors, or origin country\u2013sector pairs depending on agg.</p> <p>Term labels follow Table A2 in Wang, Wei and Zhu (2018), and the overall notation is close to Quast &amp; Kummritz (2015, decompr package).</p> <p>Returns</p> <p>WWZ_df (pandas.DataFrame)</p> <p>A DataFrame with 16 WWZ components for each observation.</p> <p>Index:</p> <ul> <li>If agg == \"\": \"\". <li>If agg == \"ORI\": origin country ISO3 codes.</li> <li>If agg == \"DES\": destination country ISO3 codes.</li> <li>If agg == \"SEC\": sector identifiers.</li> <li>If agg == \"ORI-SEC\": \"_\". <p>Columns (always the same 16 components):</p> <ul> <li>\"DVA_FIN\": Domestic VA in final goods exports</li> <li>\"DVA_INT\": Domestic VA in intermediates absorbed by direct importer</li> <li>\"DVA_INTrex1\": DVA in intermediates \u2192 direct importer \u2192 3rd-country domestic final use</li> <li>\"DVA_INTrex2\": DVA in intermediates \u2192 direct importer \u2192 final exports to 3rd countries</li> <li>\"DVA_INTrex3\": DVA in intermediates \u2192 direct importer \u2192 intermediates to 3rd countries</li> <li>\"RDV_FIN1\": Returned DVA in final imports from direct importer</li> <li>\"RDV_FIN2\": Returned DVA in final imports via 3rd countries</li> <li>\"RDV_INT\": Returned DVA in intermediate imports used domestically</li> <li>\"DDC_FIN\": Double-counted DVA used in producing final exports</li> <li>\"DDC_INT\": Double-counted DVA used in producing intermediate exports</li> <li>\"MVA_FIN\": Foreign VA in final goods exports (direct importer)</li> <li>\"OVA_FIN\": Other countries\u2019 VA in final goods exports (via others)</li> <li>\"MVA_INT\": Foreign VA in intermediate exports (direct importer)</li> <li>\"OVA_INT\": Other countries\u2019 VA in intermediate exports</li> <li>\"MDC\": Multilateral double-counting</li> <li>\"ODC\": Other double-counting</li> </ul> <p>Example</p> <pre><code>from intrade import load_TIVA, obj_IO, WWZ\n\n# 1. Load a TiVA/ICIO table\ntiva_dic = load_TIVA(dire=\"/path/to/ICIO/\", year=2015, typ=\"extended\")\n\n# 2. Build the IO object with all required matrices\nwio = obj_IO(tiva_dic)\n\n# 3. Full WWZ decomposition at origin country\u2013sector \u00d7 destination country level\nwwz_full = WWZ(wio)\n\n# 4. Aggregate WWZ components by origin country\nwwz_by_origin = WWZ(wio, agg=\"ORI\")\n\n# 5. Aggregate by origin sector\nwwz_by_sector = WWZ(wio, agg=\"SEC\")\n</code></pre>"},{"location":"aggregate/","title":"aggregate","text":""},{"location":"aggregate/#aggregate","title":"aggregate","text":"<p>Description</p> <p><code>aggregate</code> collapses an input\u2013output table from the country\u2013sector level to the country level, summing over all sectors and all final-demand categories. The resulting IO structure is a compact country \u00d7 country table where:</p> <ul> <li>each country has one aggregated \u201csector\u201d (suffix <code>\"_1\"</code>),</li> <li>each country has one aggregated final-demand category (suffix <code>\"_2\"</code>),</li> <li>intermediate flows become a C \u00d7 C block (Z),</li> <li>final demand becomes a C \u00d7 C block (F),</li> <li>and the returned table is the concatenation [Z | F] stored in <code>dic[\"df\"]</code>.</li> </ul> <p>Internally, the function assumes that row/column labels follow the InTrade convention:</p> <ul> <li>rows/columns are named like <code>\"ISO3_sectorCode\"</code> (e.g. <code>\"ESP_01T09\"</code>, <code>\"USA_10T39\"</code>),</li> <li>the country code is the substring before the first underscore.</li> </ul> <p>The aggregation is implemented by extracting the intermediate block and final-demand block from <code>d[\"df\"]</code>, grouping rows and columns by country, and then rebuilding a new IO dictionary with <code>S=1</code> and <code>FD=1</code>.</p> <p>Usage</p> <p><code>aggregate(d)</code></p> <p>Arguments</p> <p><code>aggregate(d)</code></p> <ul> <li> <p><code>d</code> : <code>dict</code>   InTrade IO dictionary containing at least:</p> </li> <li> <p><code>d[\"df\"]</code> : <code>pandas.DataFrame</code>     Full IO table, with the core country\u2013sector block located in the first <code>d[\"CS\"]</code> rows and columns, and the final demand block located in the next <code>d[\"CFD\"]</code> columns.</p> </li> <li> <p><code>d[\"C\"]</code> : <code>int</code>     Number of countries.</p> </li> <li> <p><code>d[\"CS\"]</code> : <code>int</code>     Total number of country\u2013sector accounts (<code>C \u00d7 S</code>) in the original table.</p> </li> <li> <p><code>d[\"CFD\"]</code> : <code>int</code>     Total number of country\u2013final-demand accounts (<code>C \u00d7 FD</code>) in the original table.</p> </li> </ul> <p>Details</p> <ol> <li>Extract intermediate block (Z)</li> </ol> <p>The intermediate-input matrix is extracted as the top-left country\u2013sector block. Countries are inferred from labels by taking the substring before \"_\". Rows are summed by exporter country, and then columns are summed by importer country. The resulting row/column labels are renamed to COUNTRY_1.</p> <p>The final-demand block is extracted from the columns immediately following the intermediate block. Final demand is aggregated by exporter (rows) and by destination country (columns). Labels are renamed to COUNTRY_1 for rows and COUNTRY_2 for final-demand columns.</p> <p>The output table and the returned dictionary updates the structural dimensions to reflect country-level aggregation:</p> <p>S = 1 (one sector per country)</p> <p>FD = 1 (one final-demand category per country)</p> <p>CS = C</p> <p>CFD = C</p> <p>Returns</p> <p>dict with:</p> <p>\"df\" : pandas.DataFrame Aggregated country-level IO table with shape (C, 2C), formed as [Z | F]:</p> <p>Columns COUNTRY_1 \u2026 are intermediate inputs (Z, country \u00d7 country)</p> <p>Columns COUNTRY_2 \u2026 are final demand (F, country \u00d7 country)</p> <p>\"C\" : int Number of countries (unchanged from input).</p> <p>\"S\" : int Number of sectors per country after aggregation (S = 1).</p> <p>\"FD\" : int Number of final-demand components per country after aggregation (FD = 1).</p> <p>\"CS\" : int Total country\u2013sector combinations after aggregation (CS = C).</p> <p>\"CFD\" : int Total country\u2013final-demand combinations after aggregation (CFD = C).</p> <p>Example</p> <pre><code>Copiar c\u00f3digo\nimport pandas as pd\nfrom intrade import aggregate\n\n# Suppose `wio` is an InTrade IO dictionary already created (e.g. from load_* + obj_IO)\n# wio[\"df\"] has labels like \"ESP_01T09\", \"USA_10T39\", etc.\n\nwio_cty = aggregate(wio)\n\ndf_cty = wio_cty[\"df\"]\nC      = wio_cty[\"C\"]\n\nprint(df_cty.shape)  # (C, 2C)\n\n# Intermediate block (Z) and final demand block (F)\nZ_cty = df_cty.iloc[:, :C]\nF_cty = df_cty.iloc[:, C:]\n\nprint(Z_cty.head())\nprint(F_cty.head())\n</code></pre> <p>Notes</p> <p>The function assumes that country codes are encoded as the substring before the first underscore in row/column labels.</p> <p>This aggregation is useful for producing compact country-level IO tables or for diagnostics and reporting when sectoral detail is not needed.</p>"},{"location":"bmt_output/","title":"BMT_output","text":""},{"location":"bmt_output/#bmt_output","title":"BMT_output","text":"<p>Description</p> <p><code>BMT_output</code> implements the BMT2025 output-based tripartite GVC decomposition and returns a tidy table that decomposes gross output into domestic vs. trade-related components, including a tripartite split of the GVC-related part. Conceptually, the function decomposes each country\u2019s (and optionally each country\u2013sector\u2019s) gross output <code>X</code> into:</p> <ul> <li>DomX: output driven by domestic final demand,</li> <li>GVC_X: output that is part of global value chain (GVC) activity,</li> <li>TradX: residual \u201ctraditional\u201d trade/output component (everything not explained by DomX or GVC_X),</li> </ul> <p>with GVC_X further decomposed into the BMT2025 tripartite components:</p> <ul> <li>GVC_PF_X: pure forward GVC output,</li> <li>GVC_TS_X: two-sided GVC output (with a split into imported vs. domestic propagation parts),</li> <li>GVC_PB_X: pure backward GVC output.</li> </ul> <p>Unlike <code>BMT_trade</code>, this routine is not bilateral: it does not return exporter\u2192importer pairs. Instead, it produces country totals and/or country\u00d7sector results, controlled by the <code>selector</code> argument. If <code>measures=True</code>, it also adds row-wise participation indicators (shares and a forwardness measure).</p> <p>Usage</p> <p><code>BMT_output(io, selector=\"all_all\", measures=True)</code></p> <p>Arguments</p> <p><code>BMT_output(io, selector=\"all_all\", measures=True)</code></p> <ul> <li> <p><code>io</code> : <code>dict</code>   InTrade IO dictionary (BM-style IO object). The function requires at least:</p> </li> <li> <p>Core arrays/matrices:</p> <ul> <li><code>\"A\"</code> : technical coefficients matrix, shape <code>(GN, GN)</code></li> <li><code>\"B\"</code> : global Leontief inverse, shape <code>(GN, GN)</code> (used for FVA-intensity terms)</li> <li><code>\"Y\"</code> : final demand by destination country, shape <code>(GN, G)</code></li> <li><code>\"Z\"</code> : intermediate flows, shape <code>(GN, GN)</code> (used to build export-to-foreign vectors)</li> <li><code>\"X\"</code> : gross output vector, shape <code>(GN,)</code></li> <li><code>\"V\"</code> : value-added coefficients vector, shape <code>(GN,)</code> (typically <code>VA/X</code>)</li> <li><code>\"VA\"</code> : value-added vector (optional here; kept for IO consistency)</li> </ul> </li> <li> <p>Names and dimensions (InTrade-style):</p> <ul> <li><code>io[\"names\"][\"c_names\"]</code> : list of country names/codes (length <code>G</code>)</li> <li><code>io[\"names\"][\"s_names\"]</code> : list of sector names/codes (length <code>N</code>)</li> <li><code>io[\"dims\"][\"C\"]</code> : number of countries <code>G</code></li> <li><code>io[\"dims\"][\"S\"]</code> : number of sectors per country <code>N</code></li> <li><code>io[\"dims\"][\"CS\"]</code> : total country\u2013sector accounts <code>GN = G\u00d7N</code></li> </ul> </li> <li> <p><code>selector</code> : <code>str</code>, default <code>\"all_all\"</code>   Output selector with format:</p> </li> </ul> <p><code>mode_granularity</code></p> <p>where:</p> <ul> <li><code>mode \u2208 {\"total\",\"all\"}</code></li> <li><code>granularity \u2208 {\"agg\",\"sectoral\",\"all\"}</code></li> </ul> <p>Examples:</p> <ul> <li> <p><code>\"total_agg\"</code>     One row per country (sector = <code>\"ALL\"</code>).</p> </li> <li> <p><code>\"total_sectoral\"</code>     One row per country\u00d7sector.</p> </li> <li> <p><code>\"all_all\"</code>     Returns BOTH aggregated + sectoral rows in the same dataframe.</p> </li> </ul> <p>Note: output-based BMT2025 has no bilateral dimension. The <code>mode</code> field is included mainly for consistency with <code>BMT_trade</code>; in this function, <code>total</code> and <code>all</code> behave equivalently.</p> <ul> <li> <p><code>measures</code> : <code>bool</code>, default <code>True</code>   If <code>True</code>, adds participation indicators computed row-wise:</p> </li> <li> <p><code>share_GVC_output</code> = <code>GVC_X / X</code></p> </li> <li><code>share_PF_output</code>  = <code>GVC_PF_X / GVC_X</code></li> <li><code>share_TS_output</code>  = <code>GVC_TS_X / GVC_X</code></li> <li><code>share_PB_output</code>  = <code>GVC_PB_X / GVC_X</code></li> <li><code>forward_output</code>   = <code>(GVC_PF_X \u2212 GVC_PB_X) / GVC_X</code></li> </ul> <p>Details</p> <ol> <li>Selector parsing (reporting level)</li> </ol> <p>The function reads <code>selector=\"mode_granularity\"</code> and activates:</p> <ul> <li>aggregated country rows (<code>sector=\"ALL\"</code>) if <code>granularity</code> includes <code>\"agg\"</code>,</li> <li> <p>country\u00d7sector rows if <code>granularity</code> includes <code>\"sectoral\"</code>.</p> </li> <li> <p>Domestic Leontief inverses</p> </li> </ul> <p>For each country <code>g</code>, a domestic Leontief inverse is computed:</p> <p><code>L_g = (I - A_gg)^{-1}</code></p> <p>where <code>A_gg</code> is the domestic block of <code>A</code> for country <code>g</code>. These domestic inverses are used repeatedly in the construction of the BMT2025 output terms.</p> <ol> <li>Exports-to-foreign vector e_s*</li> </ol> <p>A central building block is the exporter-sector vector of shipments to foreign users:</p> <p><code>e_s* = Z_s,foreign + Y_s,foreign</code></p> <p>computed as:</p> <ul> <li>row sums of intermediate flows from <code>s</code> to foreign sectors,</li> <li>plus row sums of final demand from <code>s</code> to foreign countries,</li> </ul> <p>implemented robustly with <code>np.ix_</code> to preserve 2D slices.</p> <ol> <li>Precompute foreign-output propagation by country</li> </ol> <p>For each country <code>r</code>, the function precomputes:</p> <p><code>Xexp_r = L_rr @ e_r*</code></p> <p>which represents domestic production in <code>r</code> needed to satisfy <code>r</code>\u2019s shipments to foreign destinations. This is used inside the pure-forward term for every exporter <code>s</code>.</p> <ol> <li>Tripartite GVC output decomposition</li> </ol> <p>For each country <code>s</code> (and each sector within <code>s</code>), the function computes:</p> <ul> <li>Pure forward (PF): constructed as a sum over partner countries <code>r \u2260 s</code>, combining direct cross-border propagation via <code>A_sr @ Xexp_r</code> and domestic amplification through <code>A_ss</code> and <code>L_ss</code>.</li> <li>Pure backward (PB): constructed from \u201cforeign value-added intensity\u201d terms, using:</li> <li>a global intensity component based on <code>v_j' B_js</code>,</li> <li>and a one-border adjustment based on <code>v_j' L_jj A_js L_ss</code>,   combined with total vs. domestic final demand (<code>Y_s_tot</code> and <code>Y_ss</code>).</li> <li>Two-sided (TS): defined as the remainder of GVC activity not accounted for by PF and PB, and split into:</li> <li><code>GVC_TSImp</code> : imported/intensity part,</li> <li><code>GVC_TSDom</code> : domestic propagation part,   with <code>GVC_TS_X = GVC_TSImp + GVC_TSDom</code>.</li> </ul> <p>Then:</p> <p><code>GVC_X = GVC_PF_X + GVC_PB_X + GVC_TS_X</code></p> <ol> <li>Domestic output and residual traditional component</li> </ol> <p>Domestic-demand-driven output is computed as:</p> <p><code>DomX = v_s * (L_ss @ Y_ss)</code></p> <p>and the residual traditional component is:</p> <p><code>TradX = X - DomX - GVC_X</code></p> <ol> <li>Measures (optional row-wise shares and forwardness)</li> </ol> <p>If <code>measures=True</code>, the function adds row-wise indicators summarizing GVC participation in output and the forward/backward balance.</p> <p>Returns</p> <p><code>pandas.DataFrame</code> always including:</p> <ul> <li><code>\"mode\"</code> : <code>\"total\"</code> (kept for consistency)</li> <li><code>\"country\"</code> : country label</li> <li><code>\"sector\"</code> : sector label or <code>\"ALL\"</code></li> </ul> <p>and decomposition columns:</p> <ul> <li><code>\"X\"</code> : gross output</li> <li><code>\"DomX\"</code> : output driven by domestic final demand</li> <li><code>\"TradX\"</code> : residual \u201ctraditional\u201d component</li> <li><code>\"GVC_PF_X\"</code> : pure forward GVC output</li> <li><code>\"GVC_PB_X\"</code> : pure backward GVC output</li> <li><code>\"GVC_TSImp\"</code> : imported/intensity part of two-sided GVC output</li> <li><code>\"GVC_TSDom\"</code> : domestic propagation part of two-sided GVC output</li> <li><code>\"GVC_TS_X\"</code> : total two-sided GVC output</li> <li><code>\"GVC_X\"</code> : total GVC-related output</li> </ul> <p>If <code>measures=True</code>, also includes:</p> <ul> <li><code>\"share_GVC_output\"</code>, <code>\"share_PF_output\"</code>, <code>\"share_TS_output\"</code>, <code>\"share_PB_output\"</code>, <code>\"forward_output\"</code></li> </ul> <p>Example</p> <pre><code>from intrade import BMT_output\n\n# io is an InTrade IO dictionary (e.g., produced by obj_IO / loaders)\n\n# Example 1: full output (country totals + country\u00d7sector)\nres = BMT_output(io, selector=\"all_all\", measures=True)\n\n# Example 2: country totals only\ntot = BMT_output(io, selector=\"total_agg\", measures=True)\n\n# Example 3: country\u00d7sector only (no measures)\nsec = BMT_output(io, selector=\"total_sectoral\", measures=False)\n\nprint(res.head())\nprint(tot.head())\nprint(sec.head())\n</code></pre> <p>Notes</p> <p>The function assumes that countries are stored in contiguous blocks of size N in all country\u00d7sector arrays.</p> <p>B (the global Leontief inverse) is required to construct the foreign value-added intensity term used in the pure-backward component.</p> <p>Output-based BMT2025 has no bilateral dimension; results are reported as country totals and/or country\u00d7sector rows.</p>"},{"location":"bmt_trade/","title":"BMT_trade","text":""},{"location":"bmt_trade/#bmt_trade","title":"BMT_trade","text":"<p>Description</p> <p><code>BMT_trade</code> implements the BMT2025 tripartite GVC trade decomposition and returns a tidy table of bilateral and/or total trade components, decomposing gross exports into:</p> <ul> <li>DAVAX: domestic value added absorbed abroad,</li> <li>GVC: the global value chain (cross-border) component of exports,</li> <li>and a tripartite split of GVC trade into:</li> <li>GVC_PF: pure forward GVC trade,</li> <li>GVC_TS: two-sided (multi-country) GVC trade,</li> <li>GVC_PB: pure backward GVC trade.</li> </ul> <p>The function is designed to work directly on an InTrade IO object and produces results at different reporting granularities through the <code>selector</code> argument:</p> <ul> <li>mode controls whether results are computed as:</li> <li>bilateral flows (exporter \u2192 importer),</li> <li>totals by exporter (summing across importers),</li> <li>or both.</li> <li>granularity controls whether results are reported:</li> <li>aggregated across sectors (<code>sector=\"ALL\"</code>),</li> <li>by exporter sector (<code>sector=sectors[i]</code>),</li> <li>or both.</li> </ul> <p>In addition, if <code>measures=True</code>, the function computes and attaches a set of summary indicators (shares and a \u201cforwardness\u201d measure) computed on exporter totals (by exporter and sector) and merged back into all rows.</p> <p>Usage</p> <p><code>BMT_trade(io, selector=\"all_all\", measures=True)</code></p> <p>Arguments</p> <p><code>BMT_trade(io, selector=\"all_all\", measures=True)</code></p> <ul> <li> <p><code>io</code> : <code>dict</code>   InTrade IO dictionary (BM-style IO object). It must contain, at minimum, the core matrices and dimension metadata used by the decomposition. In the current implementation the function expects:</p> </li> <li> <p>Core arrays/matrices:</p> <ul> <li><code>\"Z\"</code> : intermediate transactions matrix</li> <li><code>\"Y\"</code> : final demand matrix (country destinations)</li> <li><code>\"A\"</code> : technical coefficients matrix</li> <li><code>\"B\"</code> : Leontief inverse (used elsewhere in the IO object; not required by all steps here)</li> <li><code>\"V\"</code> : value-added coefficients vector (country\u2013sector)</li> <li><code>\"VA\"</code> : value-added vector (optional here; kept for consistency)</li> <li><code>\"X\"</code> : gross output vector (optional here; kept for consistency)</li> </ul> </li> <li> <p>Names and dimensions:</p> <ul> <li><code>io[\"names\"][\"c_names\"]</code> : list of country names/codes (length <code>G</code>)</li> <li><code>io[\"names\"][\"s_names\"]</code> : list of sector names/codes (length <code>N</code>)</li> <li><code>io[\"dims\"][\"C\"]</code> : number of countries <code>G</code></li> <li><code>io[\"dims\"][\"S\"]</code> : number of sectors per country <code>N</code></li> <li><code>io[\"dims\"][\"CS\"]</code> : total country\u2013sector accounts <code>GN = G\u00d7N</code></li> </ul> </li> <li> <p>Optional:</p> <ul> <li><code>io[\"country_codes\"]</code> : mapping to allow string country identifiers (e.g. <code>\"CHN\"</code>, <code>\"USA\"</code>) to be converted into numeric ids.   (Note: in the current version this is prepared via an internal helper but not exposed as a user argument.)</li> </ul> </li> <li> <p><code>selector</code> : <code>str</code>, default <code>\"all_all\"</code>   Controls the output detail level with the format:</p> </li> </ul> <p><code>mode_granularity</code></p> <p>where:</p> <ul> <li><code>mode \u2208 {\"bilateral\", \"total\", \"all\"}</code></li> <li><code>granularity \u2208 {\"agg\", \"sectoral\", \"all\"}</code></li> </ul> <p>Examples:</p> <ul> <li> <p><code>\"bilateral_agg\"</code>     Bilateral exporter\u2192importer results aggregated across sectors (<code>sector=\"ALL\"</code>).</p> </li> <li> <p><code>\"bilateral_sectoral\"</code>     Bilateral exporter\u2192importer results by exporter sector.</p> </li> <li> <p><code>\"total_agg\"</code>     Totals by exporter (importer is <code>NaN</code>), aggregated across sectors (<code>sector=\"ALL\"</code>).</p> </li> <li> <p><code>\"total_sectoral\"</code>     Totals by exporter and sector (importer is <code>NaN</code>).</p> </li> <li> <p><code>\"all_all\"</code>     Full output: bilateral + totals, and aggregated + sectoral.</p> </li> <li> <p><code>measures</code> : <code>bool</code>, default <code>True</code>   If <code>True</code>, computes summary measures on exporter totals (exporter, sector) and merges them back into every output row:</p> </li> <li> <p><code>share_GVC_trade</code> = <code>GVC / E</code></p> </li> <li><code>share_PF_trade</code>  = <code>GVC_PF / GVC</code></li> <li><code>share_TS_trade</code>  = <code>GVC_TS / GVC</code></li> <li><code>share_PB_trade</code>  = <code>GVC_PB / GVC</code></li> <li><code>forward_trade</code>   = <code>(GVC_PF \u2212 GVC_PB) / GVC</code></li> </ul> <p>Details</p> <ol> <li>Selector parsing (output configuration)</li> </ol> <p>The function reads <code>selector=\"mode_granularity\"</code> and activates the corresponding output blocks:</p> <ul> <li><code>want_bilateral</code> and/or <code>want_total</code></li> <li><code>want_agg</code> and/or <code>want_sectoral</code></li> </ul> <p>This allows a single call to produce compact totals or the full matrix of bilateral \u00d7 sector outcomes.</p> <ol> <li>Core objects and dimensions</li> </ol> <p>The function pulls the IO core matrices and dimension metadata from the <code>io</code> dictionary, including:</p> <ul> <li><code>G</code> (countries), <code>N</code> (sectors), and <code>GN</code> (country\u00d7sector accounts),</li> <li> <p>country and sector names used to label the output.</p> </li> <li> <p>Domestic Leontief inverses</p> </li> </ul> <p>A key ingredient is a list of country-specific domestic Leontief inverses:</p> <ul> <li>For each country <code>g</code>, compute:</li> </ul> <p><code>L_g = (I - A_gg)^{-1}</code></p> <p>where <code>A_gg</code> is the domestic block of the technical coefficient matrix for country <code>g</code>. This provides within-country propagation required to build the decomposition terms.</p> <ol> <li>Precomputations (BMT2025 components)</li> </ol> <p>To speed up the bilateral loop, two main precomputations are performed:</p> <ul> <li>Import intensity by exporter country   For each exporter <code>s</code>, compute by-sector import intensity:</li> </ul> <p><code>imp_s = \u03a3_{t\u2260s} colSums(A_ts)</code></p> <ul> <li>Exports from a country to \u201call others\u201d by importer   For each importer <code>r</code>, compute:</li> </ul> <p><code>\u03a3_{j\u2260r} e_rj</code></p> <p>where <code>e_rj</code> is the exporter-sector gross export vector from <code>r</code> to <code>j</code>.</p> <ol> <li>Bilateral loop (exporter s, importer r)</li> </ol> <p>For each ordered pair <code>(s,r)</code> with <code>r \u2260 s</code>, the function builds:</p> <ul> <li><code>e_sr</code> : exporter-sector gross exports (intermediate + final demand),</li> <li><code>q_final</code> : domestic production needed to satisfy exporter\u2019s final-absorption pathway,</li> <li><code>q_two</code> : production related to the two-sided (multi-country) pathway.</li> </ul> <p>From these, it computes (as vectors by exporter sector):</p> <ul> <li><code>DAVAX_vec = v_s * q_final</code></li> <li><code>PB_vec    = imp_s * q_final</code></li> <li><code>TS_vec    = imp_s * q_two</code></li> <li><code>GVC_vec   = e_sr - DAVAX_vec</code></li> <li><code>PF_vec    = GVC_vec - PB_vec - TS_vec</code></li> </ul> <p>These sectoral vectors can be stored either as sectoral rows or aggregated to scalars (summing over sectors), depending on <code>selector</code>.</p> <p>At the same time, the function accumulates exporter totals:</p> <ul> <li>exporter-level totals (aggregated across sectors),</li> <li> <p>and exporter\u00d7sector totals (sectoral).</p> </li> <li> <p>Total rows (by exporter)</p> </li> </ul> <p>If <code>mode</code> includes totals, the function appends rows with:</p> <ul> <li><code>mode=\"total\"</code></li> <li><code>importer=np.nan</code></li> </ul> <p>and the same decomposition columns, either aggregated or sectoral.</p> <ol> <li>Measures (optional shares and forwardness)</li> </ol> <p>If <code>measures=True</code>, the function computes exporter-total measures for:</p> <ul> <li><code>sector=\"ALL\"</code> and sectoral entries, then merges them back into the output table by <code>[\"exporter\",\"sector\"]</code>, so every row carries the same exporter-sector totals and shares.</li> </ul> <p>Returns</p> <p><code>pandas.DataFrame</code> always containing:</p> <ul> <li><code>\"mode\"</code> : <code>{\"bilateral\",\"total\"}</code></li> <li><code>\"exporter\"</code> : exporter country label</li> <li><code>\"importer\"</code> : importer country label (or <code>NaN</code> for totals)</li> <li><code>\"sector\"</code> : <code>\"ALL\"</code> or exporter sector label</li> </ul> <p>and decomposition columns (depending on selector, but typically):</p> <ul> <li><code>\"E\"</code> : gross exports (intermediate + final demand)</li> <li><code>\"DAVAX\"</code> : domestic VA absorbed abroad</li> <li><code>\"GVC\"</code> : GVC-related exports (<code>E \u2212 DAVAX</code>)</li> <li><code>\"GVC_PF\"</code> : pure forward GVC trade</li> <li><code>\"GVC_TS\"</code> : two-sided GVC trade</li> <li><code>\"GVC_PB\"</code> : pure backward GVC trade</li> </ul> <p>If <code>measures=True</code>, additional columns are included:</p> <ul> <li><code>\"E_s\"</code>, <code>\"GVC_s\"</code>, <code>\"GVC_PF_s\"</code>, <code>\"GVC_TS_s\"</code>, <code>\"GVC_PB_s\"</code> (exporter totals by sector)</li> <li><code>\"share_GVC_trade\"</code>, <code>\"share_PF_trade\"</code>, <code>\"share_TS_trade\"</code>, <code>\"share_PB_trade\"</code>, <code>\"forward_trade\"</code></li> </ul> <p>Example</p> <pre><code>from intrade import BMT_trade\n\n# io is an InTrade IO dictionary (e.g., produced by obj_IO / loaders)\n# Example 1: full output (bilateral + totals, agg + sectoral)\nres = BMT_trade(io, selector=\"all_all\", measures=True)\n\n# Example 2: exporter totals only, aggregated across sectors\ntot = BMT_trade(io, selector=\"total_agg\", measures=True)\n\n# Example 3: bilateral by sector\nbil_sec = BMT_trade(io, selector=\"bilateral_sectoral\", measures=False)\n\nprint(res.head())\nprint(tot.head())\n</code></pre> <p>Notes</p> <p>The function assumes that countries are indexed in blocks of size N (sectors) in all country\u00d7sector matrices.</p> <p>Domestic inverses are computed country-by-country ((I - A_gg)^{-1}), so the decomposition uses within-country propagation combined with cross-country technical links through the relevant blocks of A.</p> <p>The output is returned in a tidy long format so it can be directly used in reporting, plotting, and further aggregation workflows.</p>"},{"location":"grav_panel/","title":"grav_panel","text":""},{"location":"grav_panel/#grav_panel","title":"grav_panel","text":"<p>Description</p> <p>Panel gravity estimation with flexible fixed effects (PPML). <code>grav_panel</code> estimates a panel gravity model using PPML (statsmodels.GLM with Poisson family) and flexible combinations of fixed effects:</p> <ul> <li>Exporter (e)</li> <li>Importer (i)</li> <li>Border-year (y)</li> <li>Exporter-year (ey)</li> <li>Importer-year (iy)</li> <li>Exporter-importer pair (ei)</li> </ul> <p>It is designed for large bilateral panel datasets and returns the fitted model plus a cleaned regressor matrix and FE information.</p> <p>Usage</p> <p><code>grav_panel(data: pd.DataFrame, fe: Iterable[str], ref_country: Union[str, None] = None, verbose: bool = True)</code></p> <p>Arguments</p> <p><code>data</code> (pandas.DataFrame) : Bilateral panel trade data in long format, with at least:   - <code>exporter</code>: exporter country code   - <code>importer</code>: importer country code   - <code>year</code>: time identifier   - <code>trade</code>: bilateral trade flow $X_{ijt}$</p> <p><code>fe</code> (iterable of str) : Codes indicating which fixed effects to include:   - <code>'e'</code>: exporter FE   - <code>'i'</code>: importer FE   - <code>'y'</code>: time\u2013border FE   - <code>'ey'</code>: exporter-year FE   - <code>'iy'</code>: importer-year FE   - <code>'ei'</code>: exporter-importer FE</p> <p><code>ref_country</code> (str or None, default None) : Reference country whose FEs are dropped to avoid collinearity. If None, one exporter is randomly selected.</p> <p><code>verbose</code> (bool, default True) : If True, prints basic information and the PPML summary.</p> <p>Details</p> <p>The function:</p> <ol> <li>Checks required columns: <code>\"exporter\"</code>, <code>\"importer\"</code>, <code>\"year\"</code>, <code>\"trade\"</code>.</li> <li>Constructs border dummy <code>BRDR</code> (1 for international, 0 for domestic).</li> <li>Computes exporter output and importer expndr (total exports and imports).</li> <li>Builds the requested dummy matrices for FEs using <code>pandas.get_dummies</code>.</li> <li>Drops redundant columns involving the reference country and, if present, the baseline <code>BRDR_y_fe_0</code>.</li> <li>Estimates: $$E[X_{ijt}] = \\exp(X_{ijt}\\beta)$$ via PPML with robust (HC3) covariance.</li> </ol> <p>Value</p> <p>A dictionary with:</p> <ul> <li><code>\"results\"</code>: statsmodels GLMResults object</li> <li><code>\"params\"</code>: DataFrame with <code>beta_hat</code>, <code>std_err</code>, <code>p_value</code></li> <li><code>\"data\"</code>: original data with added FE dummies and constructed variables</li> <li><code>\"X\"</code>: final regressor matrix used in estimation</li> <li><code>\"y\"</code>: dependent variable (trade)</li> <li><code>\"ref_country\"</code>: reference country actually used</li> <li><code>\"fe\"</code>: set of FE codes used</li> <li><code>\"n_fe\"</code>: number of FE dummies included in X</li> </ul> <p>Example</p> <pre><code>from intrade import grav_panel\n\nout = grav_panel(\n    data=df_panel,\n    fe=['ey', 'iy'],\n    ref_country='USA',\n    verbose=True,\n)\n\nprint(out[\"results\"].summary())\ncoef_table = out[\"params\"]\n\nout = grav_panel(\n    data,\n    fe=['ey', 'iy'],\n    ref_country=None,\n    verbose=True,\n)\n</code></pre>"},{"location":"intrade-package/","title":"0- InTrade-package","text":""},{"location":"intrade-package/#0-intrade-package","title":"0- InTrade-package","text":"<p>Description</p> <p>The <code>intrade</code> Python package provides a unified toolkit for empirical work at the intersection of input\u2013output analysis, structural gravity, and economic complexity.</p> <p>It is built around a common world input\u2013output (WIO) object and offers:</p> <ul> <li>Data loading &amp; harmonisation</li> <li>Convenience loaders for major MRIO databases: ADB, Eora26, FIGARO, GLORIA,     OECD ICIO/TiVA, WIOD, plus small synthetic examples for testing (from: WWZ,decompr and exvatools).</li> <li> <p>A consistent internal format (countries \u00d7 sectors \u00d7 final demand) designed     to make different data sources interchangeable in downstream analysis.</p> </li> <li> <p>Global Value Chain (GVC) and value-added trade analysis</p> </li> <li>Wang\u2013Wei\u2013Zhu (WWZ) decomposition and Koopman\u2013Wang\u2013Wei(KWW) style aggregation of domestic and     foreign value added in exports.</li> <li> <p>Borin &amp; Mancini (BM) \u2013type decompositions of value added in gross exports     using a WIO object.</p> </li> <li> <p>Structural gravity modelling</p> </li> <li>Panel gravity estimation using PPML with flexible exporter, importer,     time and bilateral fixed effects.</li> <li>Structural gravity counterfactuals with exact-hat algebra in the spirit of     Anderson\u2013van Wincoop and ACR-style welfare analysis (changes in exports,     real income, output and consumer prices).</li> </ul> <p>The library is intended for researchers and practitioners working with multi-country input\u2013output tables and bilateral trade data, providing modular building blocks for both teaching and applied research in trade, GVCs and development.</p> <p>The package aims to complement existing tools such as the R packages  <code>decompr</code> or <code>exvatools</code> for decomposition and typical gravity toolkits, but in the Python ecosystem.</p> <p>Flow chart</p> <p></p> <p>Main dependencies</p> <ul> <li><code>numpy</code></li> <li><code>pandas</code></li> <li><code>statsmodels</code></li> <li><code>scipy</code></li> <li><code>os</code></li> <li><code>glob</code></li> <li><code>zipfile</code></li> <li><code>re</code></li> <li><code>itertools</code></li> <li><code>pyfixest</code></li> <li><code>traceback</code></li> <li><code>statsmodels.api</code></li> <li><code>from scipy import optimize</code></li> <li><code>from natsort import natsorted</code></li> <li><code>from zipfile import ZipFile</code></li> </ul> <p>References</p> <ul> <li>Arkolakis, C., Costinot, A., &amp; Rodr\u00edguez-Clare, A. (2012). New trade models, same old gains? American Economic Review, 102(1), 94\u2013130.</li> <li>Anderson, J. E., &amp; van Wincoop, E. (2003). Gravity with gravitas: A solution to the border puzzle. American Economic Review, 93(1), 170\u2013192.</li> <li>Borin, A., and Michele Mancini, M. (2023). \u201cMeasuring What Matters in Value-Added Trade.\u201d Economic Systems Research, January, 1\u201328. https://doi.org/10.1080/09535314.2022.2153221.</li> <li>Borin, A., Mancini, M. &amp; Taglioni, D. (2025) \"Economic Consequences of Trade and Global Value Chain Integration: A Measurement Perspective\", The World Bank Economic Review, lhaf017, https://doi.org/10.1093/wber/lhaf017</li> <li>Hummels, D., Ishii, J., &amp; Yi, K. M. (2001). The nature and growth of vertical specialization in world trade. Journal of International Economics, 54(1), 75\u201396. https://doi.org/10.1016/S0022-1996(00)00093-3.</li> <li>Koopman, R., Wang, Z., &amp; Wei, S. J. (2014). Tracing value-added and double counting in gross exports. American Economic Review, 104(2), 459\u2013494.  https://doi.org/10.1257/aer.104. Quast, B., &amp; Kummritz, V. (2015). decompr: Global value chain decomposition in R (CTEI Working Paper No. 1). The Graduate Institute, Geneva. https://qua.st/decompr/.</li> <li>OECD. 2023. \u201cOECD Inter-Country Input-Output Database.\u201d http://oe.cd/icio.</li> <li>Remond-Tierrez, I., and Rueda-Cantuche, J.M. eds. (2019). EU Inter-Country Supply, Useand Input-Output Tables: Full International and Global Accounts for Research in Input Output Analysis (FIGARO): 2019 Edition. LU: EU Publications Office. https://doi.org/10.2785/008780.</li> <li>Wang, Z., Wei, S. J., &amp; Zhu, K. (2013). Quantifying international production sharing at the bilateral and sector levels (NBER Working Paper No. 19677). National Bureau of Economic Research. http://www.nber.org/papers/w19677.pdf.</li> </ul>"},{"location":"load_adb/","title":"load_ADB","text":""},{"location":"load_adb/#load_adb","title":"load_ADB","text":"<p>Description</p> <p><code>load_ADB</code> reads an Asian Development Bank (ADB) multi-regional input\u2013output (MRIO) table from an Excel file, performs basic cleaning, infers the main MRIO dimensions (number of countries, sectors, and final-demand components), and converts ADB country codes to ISO3 / ISO3-like codes (including regional aggregates such as RoW, etc.).</p> <p>It returns a convenient dictionary with the cleaned matrix and basic dimension metadata, ready to be passed to downstream MRIO / value-added decomposition functions.</p> <p>Usage</p> <p><code>load_ADB(dire, year, typ=\"LAC\")</code></p> <p>Arguments</p> <p><code>load_ADB(dire, year, typ=\"LAC\")</code></p> <ul> <li> <p><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Directory where the ADB Excel files are stored. It should normally include the trailing separator, e.g. <code>\"path/to/ADB/\"</code>.</p> </li> <li> <p><code>year</code> : <code>int</code>   Reference year of the ADB MRIO to load. Valid years depend on <code>typ</code> and on which ADB files are present in <code>dire</code>, for example:</p> </li> <li><code>\"LAC\"</code>: 2007, 2011, 2017 (Latin American MRIO releases used here).</li> <li><code>\"CUR-62\"</code>: 2000, 2007, and annual series after 2007 according to file naming conventions.</li> <li> <p><code>\"CUR-72\"</code>: any year for which an <code>ADB-MRIO-{year}*.xlsx</code> file exists in <code>dire</code>.</p> </li> <li> <p><code>typ</code> : <code>{\"LAC\", \"CUR-62\", \"CUR-72\"}</code>, default <code>\"LAC\"</code>   Variant of the ADB MRIO to load:</p> </li> <li><code>\"LAC\"</code>: Latin American MRIO, with explicit Latin American region codes (e.g. RoLAC).</li> <li><code>\"CUR-62\"</code>: \u201cCurrent\u201d 62-region MRIO (standard ADB release).</li> <li><code>\"CUR-72\"</code>: \u201cCurrent\u201d 72-region MRIO (extended ADB release).</li> </ul> <p>Details</p> <p>The function executes the following steps:</p> <ol> <li>Select and read the Excel file</li> <li>For <code>typ=\"LAC\"</code> and <code>typ=\"CUR-62\"</code>, the file name is built explicitly from <code>year</code> (e.g. <code>\"ADB-MRIO-LAC-2017_Mar2022-2.xlsx\"</code>, <code>\"ADB-MRIO62-2018_Dec2022.xlsx\"</code>).</li> <li>For <code>typ=\"CUR-72\"</code>, the function searches <code>dire</code> using a glob pattern (<code>\"ADB-MRIO-{year}*.xlsx\"</code>) and reads the first match.</li> <li> <p>In all cases, it reads the sheet named <code>\"ADB MRIO {year}\"</code>, skipping the first four header rows and reading a fixed number of rows/columns (<code>nrows</code> and <code>usecols</code> depend on the variant).</p> </li> <li> <p>Build country\u2013sector labels</p> </li> <li>The first two rows of the data area (country and sector headers) are combined into single labels of the form <code>\"COUNTRY_SECTOR\"</code>.</li> <li>The first two columns (row identifiers) are also combined into <code>\"COUNTRY_SECTOR\"</code> row labels.</li> <li> <p>Suffix <code>\"_c\"</code> in ADB labels is removed to obtain cleaner codes.</p> </li> <li> <p>Clean structure and rename output column</p> </li> <li>The first two header rows and the first two identifier columns are dropped.</li> <li> <p>The last column is renamed to <code>\"OUT\"</code>, interpreted as total output for each country\u2013sector.</p> </li> <li> <p>Infer MRIO dimensions</p> </li> <li>A reference country (hard-coded as <code>\"AUS\"</code>) is used to infer:<ul> <li><code>S</code>: number of sectors per country, by counting how many rows belong to a specific country.</li> <li><code>SplusFD</code>: number of columns (intermediate + final demand) associated with a specific country.</li> <li><code>FD = SplusFD - S</code>: number of final-demand components per country.</li> </ul> </li> <li> <p>Given the total number of rows, the number of countries is computed as <code>C = n_rows / S</code>, and:</p> <ul> <li><code>CS = C \u00d7 S</code>: number of country\u2013sector pairs.</li> <li><code>CFD = C \u00d7 FD</code>: number of country\u2013final-demand columns.</li> </ul> </li> <li> <p>Convert ADB country codes to ISO3 / ISO-like codes</p> </li> <li>A fixed mapping from ADB internal codes (e.g. <code>\"SWI\"</code>, <code>\"PRC\"</code>, <code>\"SPA\"</code>) to ISO3 codes (<code>\"CHE\"</code>, <code>\"CHN\"</code>, <code>\"ESP\"</code>) is applied.</li> <li>Some codes correspond to regional aggregates (e.g. <code>\"RoW\"</code>, <code>\"RoLAC\"</code>), which are converted to stable labels (e.g. <code>\"RoW\"</code>, <code>\"RoL\"</code>) and treated as pseudo-ISO3 codes.</li> <li> <p>The mapping is applied to both column and row labels by replacing the leading code in each <code>\"CODE_sector\"</code> string.</p> </li> <li> <p>Natural sorting and numeric conversion</p> </li> <li>Columns are rearranged so that:<ul> <li>The first <code>CS</code> columns correspond to all country\u2013sector intermediate-use blocks.</li> <li>These are followed by all final-demand columns.</li> <li>The final <code>\"OUT\"</code> column is kept as the last column.</li> </ul> </li> <li>Within each block, columns are ordered using \u201cnatural\u201d sorting, so sector indices follow <code>1, 2, 3, 10, 11, \u2026</code> instead of lexicographic order.</li> <li>The same logic is applied to the row dimension, if needed.</li> <li> <p>All entries are converted to numeric using <code>pandas.to_numeric(..., errors=\"coerce\")</code>, turning any non-numeric \u201cjunk\u201d into <code>NaN</code>.</p> </li> <li> <p>Packaging results</p> </li> <li>A dictionary is built with the cleaned matrix and the inferred dimensions (<code>C</code>, <code>S</code>, <code>FD</code>, <code>CS</code>, <code>CFD</code>), which can be directly used by other functions in the library (e.g. MRIO decomposition or value-added export calculations).</li> </ol> <p>Returns</p> <p><code>dict</code> with the following keys:</p> <ul> <li><code>\"df\"</code> : <code>pandas.DataFrame</code>   Cleaned ADB MRIO table with:</li> <li>Index: country\u2013sector labels (e.g. <code>\"DEU_1\"</code>, <code>\"ESP_15\"</code>), after converting ADB codes to ISO3 / ISO-like codes.</li> <li> <p>Columns ordered as:</p> <ol> <li>All <code>CS</code> country\u2013sector intermediate-use columns.</li> <li>All <code>CFD</code> final-demand columns.</li> <li>One total output column <code>\"OUT\"</code>.</li> </ol> </li> <li> <p><code>\"C\"</code> : <code>int</code>   Number of countries/regions in the MRIO table.</p> </li> <li> <p><code>\"S\"</code> : <code>int</code>   Number of sectors per country.</p> </li> <li> <p><code>\"FD\"</code> : <code>int</code>   Number of final-demand components per country.</p> </li> <li> <p><code>\"CS\"</code> : <code>int</code>   Total number of country\u2013sector pairs (<code>C \u00d7 S</code>).</p> </li> <li> <p><code>\"CFD\"</code> : <code>int</code>   Total number of country\u2013final-demand pairs (<code>C \u00d7 FD</code>).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_ADB\n\n# Directory where the ADB MRIO Excel files are stored\nadb_dir = \"/path/to/ADB/files/\"\n\n# Example 1: Latin-American MRIO (LAC), year 2017\nadb_lac_2017 = load_ADB(dire=adb_dir, year=2017, typ=\"LAC\")\n\ndf_lac = adb_lac_2017[\"df\"]\nC_lac  = adb_lac_2017[\"C\"]\nS_lac  = adb_lac_2017[\"S\"]\nFD_lac = adb_lac_2017[\"FD\"]\n\n# Example 2: 62-region \"current\" MRIO (CUR-62), year 2018\nadb_cur62_2018 = load_ADB(dire=adb_dir, year=2018, typ=\"CUR-62\")\n\ndf_62  = adb_cur62_2018[\"df\"]\nC_62   = adb_cur62_2018[\"C\"]\nS_62   = adb_cur62_2018[\"S\"]\n\n# The returned df can be passed to downstream routines,\n# e.g. to construct a WIO dictionary or perform VA decomposition.\n</code></pre> <p>Notes</p> <p>Implemented with the following with the following original files:</p> <p>Current 62:</p> <ul> <li>'ADB-MRIO-2000_Mar2022-3.xlsx',</li> <li>'ADB-MRIO-2007.xlsx',</li> <li>'ADB-MRIO-2008_Mar2022.xlsx', ... to 'ADB-MRIO-2016_Mar2022.xlsx',</li> <li>'ADB-MRIO62-2017_Dec2022.xlsx', ... to 'ADB-MRIO62-2019_Dec2022.xlsx',</li> <li>'ADB-MRIO62-2020_June2023.xlsx', ... to 'ADB-MRIO62-2022_June2023.xlsx',</li> </ul> <p>Current 72:</p> <ul> <li>'ADB-MRIO-2017_Dec2022-2.xlsx',</li> <li>'ADB-MRIO-2018_Dec2022.xlsx',</li> <li>'ADB-MRIO-2019_Dec2022.xlsx',</li> <li>'ADB-MRIO-2020_June2023.xlsx',</li> <li>'ADB-MRIO-2021_June2023.xlsx',</li> <li>'ADB-MRIO-2022_June2023.xlsx',</li> </ul> <p>LAC:</p> <ul> <li>'ADB-MRIO-LAC-2007_Mar2022-1.xlsx',</li> <li>'ADB-MRIO-LAC-2011_Mar2022.xlsx',</li> <li>'ADB-MRIO-LAC-2017_Mar2022-2.xlsx',</li> </ul>"},{"location":"load_eora/","title":"load_EORA","text":""},{"location":"load_eora/#load_eora","title":"load_EORA","text":"<p>Description</p> <p><code>load_EORA</code> reads an Eora26 multi-regional input\u2013output (MRIO) table for a given year and price concept (basic prices or purchaser prices), combines the intermediate transactions matrix (<code>T</code>) with the final demand matrix (<code>FD</code>), and infers the basic MRIO dimensions: number of countries, sectors, and final-demand components.</p> <p>Country codes in Eora26 are already in ISO3 format (plus some aggregate regions such as <code>ROW</code>). These are combined with sector labels to form keys like <code>\"USA_Agriculture\"</code>, which are used as row and column labels in the returned DataFrame.</p> <p>Usage</p> <p><code>load_EORA(dire, year, typ=\"pp\")</code></p> <p>Arguments</p> <p><code>load_EORA(dire, year, typ=\"pp\")</code></p> <ul> <li> <p><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Directory where the Eora26 zip files are stored. It should normally include the trailing separator, e.g. <code>\"path/to/EORA/raw/\"</code>.</p> </li> <li> <p><code>year</code> : <code>int</code>   Reference year of the Eora26 MRIO to load (typically between 1990 and 2016, depending on data availability).</p> </li> <li> <p><code>typ</code> : <code>{\"bp\", \"pp\"}</code>, default <code>\"pp\"</code>   Price concept of the Eora26 MRIO:</p> </li> <li><code>\"bp\"</code>: basic prices.</li> <li><code>\"pp\"</code>: purchaser prices.</li> </ul> <p>Details</p> <p>The function performs the following steps:</p> <ol> <li> <p>Open the Eora26 zip file and read the text files    It expects a zip archive named:    ```text    Eora26_{year}_{typ}.zip with the following content:</p> </li> <li> <p>Eora26_{year}_{typ}_T.txt : intermediate transactions matrix (T)</p> </li> <li>Eora26_{year}_{typ}_FD.txt : final demand matrix (FD)</li> <li>Eora26_{year}_{typ}_VA.txt : value added vector (VA, read but not used here)</li> <li>labels_T.txt : labels for rows/columns of T</li> <li>labels_FD.txt : labels for columns of FD</li> </ol> <p>The function uses zipfile.ZipFile to open the archive and pandas.read_csv (with tab separator, no header) to read each text file into DataFrames: df_T, df_FD, df_VA, df_lT, df_lFD.</p> <ol> <li> <p>Build country\u2013sector labels Label files (labels_T.txt, labels_FD.txt) have a typical structure:</p> </li> <li> <p>Column 1: country code (ISO3 or aggregate like ROW)</p> </li> <li> <p>Column 3: sector or component name</p> </li> </ol> <p>The function constructs labels as \"ISO3_sector\":</p> <p><pre><code>df_T.columns = list(df_lT[1] + \"_\" + df_lT[3])\ndf_T.index   = list(df_lT[1] + \"_\" + df_lT[3])\n\ndf_FD.columns = list(df_lFD[1] + \"_\" + df_lFD[3])\ndf_FD.index   = list(df_lT[1] + \"_\" + df_lT[3])\n</code></pre> so that:</p> <ul> <li>Rows of both T and FD correspond to the same set of country\u2013sector accounts.</li> <li> <p>Columns of T are country\u2013sector uses, and columns of FD are final-demand components.</p> </li> <li> <p>Combine intermediate transactions and final demand The main MRIO table df is obtained by merging the two matrices on their common index:</p> </li> </ul> <p><pre><code>df = pd.merge(df_T, df_FD, left_index=True, right_index=True)\n</code></pre> The resulting DataFrame has:</p> <ul> <li>Rows: country\u2013sector labels (plus, potentially, an aggregate like ROW).</li> <li>Columns: all intermediate-use columns (from T), followed by all final-demand columns (from FD).</li> <li>Infer number of sectors (S) and final-demand components (FD) Using a reference country (ref = \"USA\"), the function infers: S: number of sectors per country, as the number of rows belonging to the reference country:</li> </ul> <pre><code>S = df.T.filter(like=\"USA\").shape[1]\nSplusFD: total number of columns corresponding to the reference country (sectors + final demand):\n</code></pre> <pre><code>SplusFD = int(df.filter(like=\"USA\").shape[1])\n</code></pre> <p>FD: number of final-demand components per country.</p> <p>Eora26 typically includes a ROW (rest-of-world) aggregate that does not always have the full sectoral detail. The function assumes: <code>filas_adic = 1</code>additional row (the ROW aggregate).</p> <p>Then:</p> <ul> <li>C = (number_of_rows - filas_adic) / S: number of countries/regions.</li> <li>CS = C \u00d7 S: total country\u2013sector rows.</li> <li>CFD = C \u00d7 FD: total country\u2013final-demand columns.</li> </ul> <p>As a cross-check, it also computes: <code>C0 = df_lFD[0].nunique()</code>  and compares C0 with C. If they differ, the function warns that at least one country (e.g. ROW) does not have the full set of sectors and will be dropped.</p> <p>Drop ROW (rest-of-world aggregate) To obtain a consistent square block of country\u2013sector accounts, the function removes:</p> <p>Any row whose index starts with \"ROW\".</p> <p>Any column whose label starts with \"ROW\".</p> <pre><code>df = df[~df.index.str.startswith(\"ROW\")]\ndf = df.loc[:, ~df.columns.str.startswith(\"ROW\")]\n</code></pre> <p>Finally, the function builds a dictionary:</p> <p><pre><code>dic = {\n    \"df\": df,\n    \"C\": int(C),\n    \"S\": int(S),\n    \"FD\": int(FD),\n    \"CS\": int(CS),\n    \"CFD\": int(CFD),\n}\n</code></pre> which contains both the combined MRIO table and the inferred dimensions.</p> <p>Returns</p> <p>dict with the following keys:</p> <ul> <li> <p>\"df\" : pandas.DataFrame   Combined Eora26 MRIO table with:</p> </li> <li> <p>Rows: country\u2013sector accounts for all countries except the dropped ROW aggregate (e.g. \"USA_Agriculture\", \"ESP_Manufacturing\").</p> </li> <li> <p>Columns: all country\u2013sector intermediate-use entries followed by all final-demand components.</p> </li> <li> <p>\"C\" : int Number of countries/regions (before dropping ROW, used to infer dimensions).</p> </li> <li> <p>\"S\" : int Number of sectors per country.</p> </li> <li> <p>\"FD\" : int Number of final-demand components per country.</p> </li> <li> <p>\"CS\" : int Total number of country\u2013sector rows (C \u00d7 S).</p> </li> <li> <p>\"CFD\" : int Total number of country\u2013final-demand columns (C \u00d7 FD).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_EORA\n\n# Directory where Eora26 zip files are stored\neora_dir = \"/path/to/EORA/raw/\"\n\n# Example 1: Eora26 MRIO at purchaser prices (pp), year 2010\neora_pp_2010 = load_EORA(dire=eora_dir, year=2010, typ=\"pp\")\n\ndf_pp  = eora_pp_2010[\"df\"]\nC_pp   = eora_pp_2010[\"C\"]\nS_pp   = eora_pp_2010[\"S\"]\nFD_pp  = eora_pp_2010[\"FD\"]\n\n# Example 2: Eora26 MRIO at basic prices (bp), year 2005\neora_bp_2005 = load_EORA(dire=eora_dir, year=2005, typ=\"bp\")\n\ndf_bp  = eora_bp_2005[\"df\"]\nC_bp   = eora_bp_2005[\"C\"]\nS_bp   = eora_bp_2005[\"S\"]\n\n# The resulting df can then be transformed into a WIO structure\n# or decomposed into value-added components using other intrade functions.\n</code></pre> <p>Notes</p> <p>Implemented with the following with the following original files:</p> <ul> <li>'Eora26_1990_bp.zip', ... to 'Eora26_2017_bp.zip',</li> <li>'Eora26_1990_pp.zip', ... to 'Eora26_2017_pp.zip'</li> </ul>"},{"location":"load_figaro/","title":"load_FIGARO","text":""},{"location":"load_figaro/#load_figaro","title":"load_FIGARO","text":"<p>Description</p> <p><code>load_FIGARO</code> reads a Eurostat FIGARO inter-country input\u2013output (IC-IO) matrix for a given year and layout (industry-by-industry or product-by-product), infers the main IC-IO dimensions (number of countries, sectors/products, and final-demand components), and converts country codes from ISO2 to ISO3 using an internal mapping.</p> <p>FIGARO row/column labels are assumed to start with a 2-letter country code (e.g. <code>\"ES...\"</code>, <code>\"DE...\"</code>, <code>\"US...\"</code>), plus a specific code for the rest of the world (<code>\"FIGW1\"</code>), which is harmonised to <code>\"RW\"</code> and then converted to a pseudo-ISO3 code <code>\"ROW\"</code>.</p> <p>The function returns a cleaned DataFrame with country\u2013sector (or country\u2013product) labels of the form <code>\"ISO3_k\"</code>, where <code>k = 1, 2, \u2026, S</code> is a sector/product index in natural order.</p> <p>Usage</p> <p><code>load_FIGARO(dire, year, typ=\"ind\")</code></p> <p>Arguments</p> <p><code>load_FIGARO(dire, year, typ=\"ind\")</code></p> <ul> <li> <p><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Directory where the FIGARO CSV files are stored, e.g.   <code>\"path/to/Figaro/raw/IO_industry\"</code> or <code>\"path/to/Figaro/raw/IO_product\"</code>.   It should not include a trailing slash, since the function constructs the full path internally using <code>\"/\"</code>.</p> </li> <li> <p><code>year</code> : <code>int</code>   Reference year of the FIGARO IC-IO data (typically between 2010 and 2020, depending on the specific edition).</p> </li> <li> <p><code>typ</code> : <code>{\"ind\", \"prod\"}</code>, default <code>\"ind\"</code>   Type of FIGARO table to load:</p> </li> <li><code>\"ind\"</code>  : industry-by-industry IO table.</li> <li><code>\"prod\"</code> : product-by-product IO table.</li> </ul> <p>Details</p> <p>The function runs through the following steps:</p> <ol> <li> <p>Local ISO2 \u2192 ISO3 mapping    A local dictionary <code>iso2_to_iso3</code> is defined inside the function, covering a wide range of ISO2 codes and their ISO3 equivalents (e.g. <code>\"ES\" \u2192 \"ESP\"</code>, <code>\"DE\" \u2192 \"DEU\"</code>, <code>\"US\" \u2192 \"USA\"</code>). It also includes a mapping for <code>\"RW\" \u2192 \"ROW\"</code> so that the rest-of-world code is standardised.</p> </li> <li> <p>Read the FIGARO IC-IO CSV file    The input CSV file is read with:    ```python    df = pd.read_csv(        dire + \"/matrix_eu-ic-io_\" + typ + \"-by-\" + typ + \"24ed\" + str(year) + \".csv\",        index_col=0,    ) so the directory dire should match the structure used by Eurostat (e.g. \".../IO_industry\" for typ=\"ind\"). The first column is used as the index.</p> </li> </ol> <p>The function assumes there are a number of \u201cadditional\u201d rows outside the country\u2013sector block (e.g. taxes, value added, other aggregates), which it sets as: <code>filas_adic = 6</code></p> <ol> <li>Infer sectors/products (S) and final-demand components (FD)</li> </ol> <p>Using a reference country in ISO2 format (ref = \"US\"), the function infers:</p> <ul> <li>S: number of sectors/products per country, as: <code>S = int(df.T.filter(like=\"US\").shape[1])</code></li> <li>SplusFD: total number of columns corresponding to the reference country (sectors/products + final demand): <code>SplusFD = int(df.filter(like=\"US\").shape[1])</code></li> <li>FD = SplusFD - S`: number of final-demand components per country.</li> </ul> <p>With filas_adic additional rows, it then computes:</p> <ul> <li>C = (n_rows - filas_adic) / S : number of countries/regions.</li> <li>CS = C \u00d7 S : total number of country\u2013sector (or country\u2013product) combinations.</li> <li> <p>CFD = C \u00d7 FD : total number of country\u2013final-demand combinations.</p> </li> <li> <p>Harmonise rest-of-world code (\"FIGW1\" \u2192 \"RW\") in column labels FIGARO uses \"FIGW1\" as the code for the rest of the world. The function:</p> </li> </ul> <p><pre><code>for columna in df.columns:\n    if columna.startswith(\"FIGW1\"):\n        new_name = \"RW\" + columna[len(\"FIGW1\"):]\n        df.rename(columns={columna: new_name}, inplace=True)\n</code></pre> This makes the rest-of-world block consistent with the ISO2\u2192ISO3 mapping.</p> <ol> <li>Build a mapping from FIGARO sector labels to sector indices 1..S Using the columns belonging to the reference country ref = \"US\", the function extracts the original sector codes:</li> </ol> <p><pre><code>news_names = []\nfor columna in df.filter(like=ref).columns:\n    new_name = str(columna)[2:]  # strip first two characters (ISO2)\n    news_names.append(new_name)\n\ndiccionario_mapeo = {name: i + 1 for i, name in enumerate(news_names)}\nThis maps each original FIGARO sector/product code (e.g. \"A01\", \"B05\") to a sector index 1..S.\n</code></pre> 6. Convert country codes from ISO2 to ISO3 in columns For each column label:</p> <ul> <li>The first two characters are interpreted as an ISO2 country code.</li> <li>These two characters are replaced with the corresponding ISO3 code using iso2_to_iso3. For example, \"ES_A01\" becomes \"ESP_A01\", \"US_A01\" becomes \"USA_A01\".</li> </ul> <p>The transformation is:</p> <pre><code>new_column_names = []\nfor column_name in df.columns:\n    first_two_letters = column_name[:2]\n    new_first_two_letters = iso2_to_iso3.get(first_two_letters, first_two_letters)\n    new_column_name = new_first_two_letters + column_name[2:]\n    new_column_names.append(new_column_name)\ndf.columns = new_column_names\n</code></pre> <ol> <li>Append sector indices to column labels (\"ISO3_k\") Using diccionario_mapeo, the function replaces the original sector substring at the end of each column label with a numeric index:</li> </ol> <pre><code>for columna in df.columns:\n    for parte_original, parte_nueva in diccionario_mapeo.items():\n        if columna.endswith(parte_original):\n            new_name = columna.rsplit(parte_original, 1)[0] + \"_\" + str(parte_nueva)\n            df.rename(columns={columna: new_name}, inplace=True)\n</code></pre> <p>After this step, column labels have the form \"ISO3_1\", \"ISO3_2\", \u2026, \"ISO3_S\" for the intermediate block; final-demand columns follow with their own labels.</p> <ol> <li> <p>Repeat the harmonisation for rows The table is transposed and the same procedures are applied to row labels (now columns):</p> </li> <li> <p>Harmonise \"FIGW1\" \u2192 \"RW\".</p> </li> <li>Apply ISO2\u2192ISO3 mapping.</li> <li>Append sector indices using diccionario_mapeo.</li> </ol> <p>Then the table is transposed back to its original orientation.</p> <p>Natural ordering of country\u2013sector blocks and FD components</p> <p>The function ensures:</p> <ul> <li>The first CS columns correspond to all country\u2013sector blocks, sorted in natural order using natsorted, so sector indices follow 1, 2, 3, 10, 11, \u2026.</li> <li> <p>The remaining columns (final demand) are similarly sorted. This is done column-wise and then row-wise (on the transposed DataFrame) to guarantee a clean, consistent ordering.</p> </li> <li> <p>Package results</p> </li> </ul> <p>Finally, all relevant objects are bundled into a dictionary:</p> <pre><code>dic = {\n    \"df\": df,\n    \"C\": int(C),\n    \"S\": int(S),\n    \"FD\": int(FD),\n    \"CS\": int(CS),\n    \"CFD\": int(CFD),\n}\n</code></pre> <p>Returns</p> <p>dict with the following keys:</p> <ul> <li> <p>\"df\" : pandas.DataFrame   Cleaned FIGARO IC-IO matrix with:</p> </li> <li> <p>Rows: country\u2013sector (or country\u2013product) plus a small number of extra rows (e.g. aggregates).</p> </li> <li> <p>Columns: all CS country\u2013sector intermediate-use blocks, followed by all CFD final-demand components.   Country codes are in ISO3 (or \"ROW\" for rest-of-world), and sectors/products are indexed as 1..S (natural order).</p> </li> <li> <p>\"C\" : int Number of countries/regions.</p> </li> <li> <p>\"S\" : int Number of sectors/products per country.</p> </li> <li> <p>\"FD\" : int Number of final-demand components per country.</p> </li> <li> <p>\"CS\" : int Total number of country\u2013sector combinations (C \u00d7 S).</p> </li> <li> <p>\"CFD\" : int Total number of country\u2013final-demand combinations (C \u00d7 FD).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_FIGARO\n\n# Directory where FIGARO industry-by-industry tables are stored\nfigaro_ind_dir = \"/path/to/Figaro/raw/IO_industry\"\n\n# Example 1: Industry-by-industry FIGARO table, year 2015\nfigaro_ind_2015 = load_FIGARO(dire=figaro_ind_dir, year=2015, typ=\"ind\")\n\ndf_ind  = figaro_ind_2015[\"df\"]\nC_ind   = figaro_ind_2015[\"C\"]\nS_ind   = figaro_ind_2015[\"S\"]\nFD_ind  = figaro_ind_2015[\"FD\"]\n\n# Directory where FIGARO product-by-product tables are stored\nfigaro_prod_dir = \"/path/to/Figaro/raw/IO_product\"\n\n# Example 2: Product-by-product FIGARO table, year 2018\nfigaro_prod_2018 = load_FIGARO(dire=figaro_prod_dir, year=2018, typ=\"prod\")\n\ndf_prod = figaro_prod_2018[\"df\"]\nC_prod  = figaro_prod_2018[\"C\"]\nS_prod  = figaro_prod_2018[\"S\"]\n\n# The returned df can be transformed into a WIO structure or\n# used directly for IC-IO analysis and value-added decompositions.\n</code></pre> <p>Notes</p> <p>Implemented with the following with the following original files:</p> <ul> <li>'matrix_eu-ic-io_ind-by-ind_24ed_2010.csv', ... to 'matrix_eu-ic-io_ind-by-ind_24ed_2022.csv',</li> <li>'matrix_eu-ic-io_prod-by-prod_24ed_2010.csv', ... to  'matrix_eu-ic-io_prod-by-prod_24ed_2022.csv'</li> </ul>"},{"location":"load_gloria/","title":"load_GLORIA","text":""},{"location":"load_gloria/#load_gloria","title":"load_GLORIA","text":"<p>Description</p> <p><code>load_GLORIA</code> reads a GLORIA multi-regional input\u2013output (MRIO) table for a given year from a compressed zip archive, extracts:</p> <ul> <li>the intermediate transactions matrix (<code>T-Results</code>),</li> <li>the final demand matrix (<code>Y-Results</code>),</li> </ul> <p>and combines them into a single <code>pandas.DataFrame</code> with a consistent country\u2013sector and country\u2013final-demand structure.</p> <p>The implementation assumes the standard GLORIA layout:</p> <ul> <li><code>C = 164</code> countries/regions,</li> <li><code>S = 120</code> sectors per country,</li> <li><code>FD = 6</code> final-demand components per country.</li> </ul> <p>Row/column labels are constructed as:</p> <ul> <li><code>\"i_j\"</code> for country\u2013sector (i = 1..C, j = 1..S),</li> <li><code>\"i_j\"</code> for country\u2013FD (i = 1..C, j = S+1..S+FD).</li> </ul> <p>Usage</p> <p><code>load_GLORIA(dire, year)</code></p> <p>Arguments</p> <p><code>load_GLORIA(dire, year)</code></p> <ul> <li><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Directory where the GLORIA zip file is stored. It should include the trailing separator, e.g.:   ```text   \"/path/to/Gloria/\" year : int Reference year of the GLORIA MRIO to load (typically between 1990 and 2028, depending on the data release).</li> </ul> <p>Details</p> <p>The function proceeds in the following steps:</p> <ol> <li> <p>Set fixed dimensions for GLORIA The GLORIA system is very large. In this implementation the dimensions are hard-coded:</p> </li> <li> <p>C  = 164   # number of countries/regions</p> </li> <li>S  = 120   # sectors per country</li> <li>FD = 6     # final-demand components per country</li> <li>CS = 19680 # C * S</li> <li> <p>CFD = 984  # C * FD</p> </li> <li> <p>Build labels for country\u2013sector and country\u2013FD accounts</p> </li> <li> <p>Country\u2013sector labels: <code>names = [f\"{i}_{j}\" for i in range(1, C + 1) for j in range(1, S + 1)]</code></p> </li> <li> <p>Country\u2013FD labels: <code>names_fd = [f\"{i}_{j}\" for i in range(1, C + 1) for j in range(S + 1, S + FD + 1)]</code></p> </li> <li> <p>Select GLORIA zip file and define filename patterns</p> </li> </ol> <p>The function expects a zip file: <code>GLORIA_MRIOs_59_{year}.zip</code> containing CSV files for:</p> <ul> <li> <p>intermediate transactions (T-Results),</p> </li> <li> <p>final demand (Y-Results).</p> </li> </ul> <p>File name patterns (regular expressions) are:</p> <ul> <li><code>pattern  = r\".*Mother_AllCountries_002_T-Results_\" + str(year) + r\"_059_Markup001\\(full\\)\\.csv\"</code></li> <li><code>patternY = r\".*Mother_AllCountries_002_Y-Results_\" + str(year) + r\"_059_Markup001\\(full\\)\\.csv\"</code></li> </ul> <p>Inside the zip, the function searches for filenames that match these patterns.</p> <ol> <li> <p>Row/column selection for GLORIA blocks GLORIA MRIOs have repeated blocks for different purposes. This implementation selects only the relevant blocks using index rules:</p> </li> <li> <p>Rows: keep only row indices where (i // S) % 2 == 0.</p> </li> <li> <p>Columns: for T-Results, keep only column indices where (i // S) % 2 != 0.</p> </li> </ol> <p>Concretely:</p> <p><code>rows = [i for i in range(0, C * S * 2) if (i // S) % 2 == 0]</code> <code>cols = [i for i in range(0, C * S * 2) if (i // S) % 2 != 0]</code> This exploits the internal GLORIA structure where blocks are stored in alternating fashion.</p> <ol> <li> <p>Open the zip and load the T and Y matrices Using zipfile.ZipFile, the function:</p> </li> <li> <p>lists all files (namelist()),</p> </li> <li> <p>filters them with re.match(pattern, f) and re.match(patternY, f).</p> </li> </ol> <p>Then it reads:</p> <ul> <li>T matrix (intermediate transactions):</li> </ul> <pre><code>df1 = pd.read_csv(archivo_txt, skiprows=rows, usecols=cols, delimiter=\",\",  encoding=\"utf-8\",   header=None,)\n</code></pre> <ul> <li>Y matrix (final demand):</li> </ul> <p><pre><code>df2 = pd.read_csv(archivo_txt, skiprows=rows, delimiter=\",\", encoding=\"utf-8\",  header=None,)\n</code></pre> Both are read as numeric matrices without headers.</p> <ol> <li>Assign labels and combine [T | Y]</li> </ol> <p>For the intermediate block df1 (T):</p> <p><pre><code>df1.index   = names      # country\u2013sector rows\ndf1.columns = names      # country\u2013sector columns\n</code></pre> - For the final-demand block df2 (Y):</p> <p><pre><code>df2.index   = names      # same country\u2013sector rows\ndf2.columns = names_fd   # country\u2013FD columns\n</code></pre> - The final combined MRIO is:</p> <p><pre><code>df = pd.concat([df1, df2], axis=1)\n</code></pre> giving a matrix of dimension:</p> <ul> <li> <p>rows: CS country\u2013sector accounts (164 \u00d7 120 = 19,680),</p> </li> <li> <p>columns: CS + CFD (19,680 + 984) with all intermediate uses first, followed by final demand.</p> </li> <li> <p>Pack results in a dictionary The function returns:</p> </li> </ul> <p><pre><code>dic = {\n    \"df\": df,\n    \"C\": int(C),\n    \"S\": int(S),\n    \"FD\": int(FD),\n    \"CS\": int(CS),\n    \"CFD\": int(CFD),\n}\n</code></pre> This structure is ready to be transformed into a WIO object or used directly for further decompositions.</p> <p>Returns</p> <p>dict with the following keys:</p> <ul> <li>\"df\" : pandas.DataFrame Combined GLORIA MRIO table [T | Y] with:</li> </ul> <p>Rows: country\u2013sector indices \"i_j\" for i = 1..C, j = 1..S.</p> <p>Columns:   - first CS columns: intermediate transactions between country\u2013sectors \"i_j\",   - next CFD columns: final demand components \"i_j\" for j = S+1..S+FD.</p> <ul> <li> <p>\"C\" : int Number of countries/regions (fixed at 164 in this implementation).</p> </li> <li> <p>\"S\" : int Number of sectors per country (fixed at 120).</p> </li> <li> <p>\"FD\" : int Number of final-demand components per country (fixed at 6).</p> </li> <li> <p>\"CS\" : int Total number of country\u2013sector combinations (C \u00d7 S = 19,680).</p> </li> <li> <p>\"CFD\" : int Total number of country\u2013final-demand combinations (C \u00d7 FD = 984).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_GLORIA\n\n# Directory where GLORIA zip files are stored\ngloria_dir = \"/path/to/Gloria/\"\n\n# Example: Load GLORIA MRIO for year 2015\ngloria_2015 = load_GLORIA(dire=gloria_dir, year=2015)\n\ndf_gloria = gloria_2015[\"df\"]\nC        = gloria_2015[\"C\"]   # 164\nS        = gloria_2015[\"S\"]   # 120\nFD       = gloria_2015[\"FD\"]  # 6\n\n# Inspect dimensions\nprint(df_gloria.shape)  # (CS, CS + CFD) = (19680, 19680 + 984)\n\n# Example: subset a specific country (e.g. i = 10)\ncountry_i = 10\nrows_country_i = [idx for idx in df_gloria.index if idx.startswith(f\"{country_i}_\")]\ndf_country_i = df_gloria.loc[rows_country_i, :]\n\n# The resulting df_gloria can then be passed to transformation routines\n# that build a full WIO structure or perform value-added decompositions.\n</code></pre> <p>Notes</p> <p>Implemented using the following original data files:</p> <p>\u2013 GLORIA_MRIOs_59_1990.zip to GLORIA_MRIOs_59_2028.zip</p> <p>Within each ZIP archive, the following files are used:</p> <p>\u2013 20240111_120secMother_AllCountries_002_T-Results_1990_059_Markup001(full).csv ... to 20240111_120secMother_AllCountries_002_T-Results_2028_059_Markup001(full).csv</p> <p>and</p> <p>-20240111_120secMother_AllCountries_002_Y-Results_1990_059_Markup001(full).csv ... to 20240111_120secMother_AllCountries_002_Y-Results_2028_059_Markup001(full).csv</p>"},{"location":"load_test/","title":"load_Test","text":""},{"location":"load_test/#load_test","title":"load_Test","text":"<p>Description</p> <p><code>load_Test</code> builds small synthetic input\u2013output (IO) datasets that are useful for:</p> <ul> <li>testing value-added decomposition routines (e.g. Decompr-style, Exvatools-style, WWZ-style),</li> <li>writing examples and unit tests for MRIO algorithms.</li> </ul> <p>It returns a toy multi-country, multi-sector IO table plus the main structural dimensions (number of countries, sectors, and final-demand components).</p> <p>Two test layouts are currently implemented:</p> <ul> <li><code>\"decompr\"</code>: 3 countries (ARG, TUR, DEU) \u00d7 3 sectors each, 1 final-demand category. From Quast &amp; Kummritz (2015)</li> <li><code>\"exvatools\"</code>: 10 countries (ESP, FRA, MEX, USA, CHN, ROW, MX1, MX2, CN1, CN2) \u00d7 3 sectors each, 2 final-demand category. From Fe\u00e1s (2013)</li> <li><code>\"WWZ\"</code>    : 3 countries (rrr, sss, ttt) \u00d7 2 sectors each, 1 final-demand category. From Wang et al. (2013)</li> </ul> <p>The numeric values are arbitrary and only intended for illustration and testing.</p> <p>Usage</p> <p><code>load_Test(typ)</code></p> <p>Arguments</p> <p><code>load_Test(typ)</code></p> <ul> <li> <p><code>typ</code> : <code>{\"decompr\", \"WWZ\"}</code>   Selects which toy dataset to generate:</p> </li> <li> <p><code>\"decompr\"</code>     Three countries (ARG, TUR, DEU), each with 3 sectors, and 1 final-demand category per country.     This layout is compatible with Decompr-style decompositions.</p> </li> <li> <p><code>\"exvatools\"</code>     Ten \"countries\" (ESP, FRA, MEX, USA, CHN, ROW, MX1, MX2, CN1, CN2), each with 3 sectors, and 2 final-demand category per country.     This layout is compatible with Exvatools-style decompositions.</p> </li> <li> <p><code>\"WWZ\"</code>     Three countries (rrr, sss, ttt), each with 2 sectors, and 1 final-demand category per country.</p> </li> </ul> <p>If a different string is passed, the current implementation will not create a dataset and will raise an error in subsequent steps (no internal validation is performed yet).</p> <p>Details</p> <ol> <li>General structure</li> </ol> <p>For both <code>typ=\"decompr\"</code>, <code>typ=\"exvatools\"</code> and <code>typ=\"WWZ\"</code>, the function returns:</p> <ul> <li> <p><code>df</code> : a square IO matrix with:</p> <ul> <li>rows indexed by <code>country_sector</code>, e.g. <code>\"ARG_1\"</code>, <code>\"TUR_3\"</code>, <code>\"DEU_2\"</code>,    or <code>\"rrr_1\"</code>, <code>\"sss_2\"</code>, <code>\"ttt_1\"</code>.</li> <li>columns ordered as:</li> <li>All country\u2013sector intermediate-use columns (one per exporter sector),</li> <li>All country-specific final-demand columns,</li> <li>One final column <code>\"Output\"</code> with total output by country\u2013sector.</li> </ul> </li> <li> <p>Structural dimensions:</p> <ul> <li><code>C</code>   \u2013 number of countries,</li> <li><code>S</code>   \u2013 number of sectors per country,</li> <li><code>FD</code>  \u2013 number of final-demand categories per country,</li> <li><code>CS</code>  \u2013 total country\u2013sector pairs (<code>C \u00d7 S</code>),</li> <li><code>CFD</code> \u2013 total country\u2013final-demand pairs (<code>C \u00d7 FD</code>).</li> </ul> </li> <li> <p>Case <code>typ=\"decompr\"</code></p> </li> <li> <p>Countries: <code>[\"ARG\", \"TUR\", \"DEU\"]</code></p> </li> <li>Sectors (per country): <code>\"1\"</code>, <code>\"2\"</code>, <code>\"3\"</code></li> <li>Final demand: 1 category per country (<code>ARG_4</code>, <code>TUR_4</code>, <code>DEU_4</code>)</li> <li>Output: <code>\"Output\"</code> column</li> </ul> <p>The DataFrame is constructed from a hard-coded dictionary:</p> <ul> <li>Row index:      <pre><code>[\"ARG_1\", \"ARG_2\", \"ARG_3\",\n \"TUR_1\", \"TUR_2\", \"TUR_3\",\n \"DEU_1\", \"DEU_2\", \"DEU_3\"]\n</code></pre></li> <li>Columns reordered as:      <pre><code>[\"ARG_1\",\"ARG_2\",\"ARG_3\",\n \"TUR_1\",\"TUR_2\",\"TUR_3\",\n \"DEU_1\",\"DEU_2\",\"DEU_3\",\n \"ARG_4\",\"TUR_4\",\"DEU_4\",\n \"Output\"]\n</code></pre></li> </ul> <p>Dimensions for this toy dataset:</p> <ul> <li><code>C = 3</code>, <code>S = 3</code>, <code>FD = 1</code></li> <li><code>CS = 3 \u00d7 3 = 9</code></li> <li><code>CFD = 3 \u00d7 1 = 3</code></li> </ul> <p>Printed message:  ```text load_Test, decompr: Done! Case typ=\"WWZ\"</p> <ul> <li>Countries: [\"rrr\", \"sss\", \"ttt\"]</li> <li>Sectors (per country): \"1\", \"2\"</li> <li>Final demand: 1 category per country (rrr_4, sss_4, ttt_4)</li> <li> <p>Output: \"Output\" column</p> </li> <li> <p>Row index:            [\"rrr_1\", \"rrr_2\",  \"sss_1\", \"sss_2\",  \"ttt_1\", \"ttt_2\"]</p> </li> <li>Columns reordered as: [\"rrr_1\", \"rrr_2\",  \"sss_1\", \"sss_2\",  \"ttt_1\", \"ttt_2\",  \"rrr_4\",\"sss_4\",\"ttt_4\",  \"Output\"]</li> </ul> <p>Dimensions for this toy dataset:</p> <ul> <li>C = 3, S = 2, FD = 1</li> <li>CS = 3 \u00d7 2 = 6</li> <li>CFD = 3 \u00d7 1 = 3</li> </ul> <p>Intended use. These toy datasets are designed for:</p> <ul> <li>unit tests of decomposition routines (BM, WWZ components, etc.),</li> <li>examples in documentation or teaching materials,</li> <li>quick checks of consistency (row/column sums, balance conditions, etc.).</li> </ul> <p>They are not calibrated to any real economy and should never be used for empirical analysis.</p> <p>Returns</p> <p>dict with:</p> <ul> <li> <p>\"df\" : pandas.DataFrame   IO matrix with:</p> </li> <li> <p>Rows = country\u2013sector accounts (\"ARG_1\", \"TUR_2\", \"DEU_3\", \u2026 or \"rrr_2\", etc.),</p> </li> <li> <p>Columns = all intermediate-use country\u2013sector blocks, followed by country-specific final demand, and a final \"Output\" column.</p> </li> <li> <p>\"C\" : int Number of countries in the synthetic dataset.</p> </li> <li> <p>\"S\" : int Number of sectors per country.</p> </li> <li> <p>\"FD\" : int Number of final-demand categories per country.</p> </li> <li> <p>\"CS\" : int Total number of country\u2013sector combinations (C \u00d7 S).</p> </li> <li> <p>\"CFD\" : int Total number of country\u2013final-demand combinations (C \u00d7 FD).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_Test\n\n# -----------------------------------\n# 1) Decompr-style toy dataset\n# -----------------------------------\ntoy_decompr = load_Test(\"decompr\")\n\ndf_dec = toy_decompr[\"df\"]\nC_dec  = toy_decompr[\"C\"]\nS_dec  = toy_decompr[\"S\"]\nFD_dec = toy_decompr[\"FD\"]\n\nprint(df_dec)\nprint(\"Countries:\", C_dec, \"Sectors:\", S_dec, \"FD:\", FD_dec)\n\n# Example: extract intermediate-use matrix A-like block\nCS_dec = toy_decompr[\"CS\"]\nA_block = df_dec.iloc[:CS_dec, :CS_dec]  # 9x9 intermediate block (ARG/TUR/DEU \u00d7 3 sectors)\n\n# -----------------------------------\n# 2) WWZ-style toy dataset\n# -----------------------------------\ntoy_wwz = load_Test(\"WWZ\")\n\ndf_wwz = toy_wwz[\"df\"]\nC_w    = toy_wwz[\"C\"]\nS_w    = toy_wwz[\"S\"]\nFD_w   = toy_wwz[\"FD\"]\n\nprint(df_wwz)\nprint(\"Countries:\", C_w, \"Sectors:\", S_w, \"FD:\", FD_w)\n\n# Intermediate-use block (6x6) for WWZ example\nCS_w   = toy_wwz[\"CS\"]\nA_wwz  = df_wwz.iloc[:CS_w, :CS_w]\n\n# These toy matrices can now be passed to your decomposition functions, e.g.:\n#   wio = make_wio_from_df(df_dec, C=C_dec, S=S_dec, FD=FD_dec)\n#   result = BM(wio)\n</code></pre> <p>Notes</p>"},{"location":"load_tiva/","title":"load_TIVA","text":""},{"location":"load_tiva/#load_tiva","title":"load_TIVA","text":"<p>Description</p> <p><code>load_TIVA</code> reads an OECD Inter-Country Input\u2013Output (ICIO) / TiVA table from a compressed CSV file (inside a zip archive), performs basic checks and cleaning, reconstructs the <code>\"OUT\"</code> (total output) column if necessary, and infers the main ICIO dimensions (number of countries, sectors and final-demand components).</p> <p>For extended ICIO releases, it also merges split entries for Mexico and China (<code>MX1 + MX2 \u2192 MEX</code>, <code>CN1 + CN2 \u2192 CHN</code>) both in rows and columns, so each country is represented by a single ISO3-like code.</p> <p>Usage</p> <p><code>load_TIVA(dire, year, typ=\"extended\")</code></p> <p>Arguments</p> <p><code>load_TIVA(dire, year, typ=\"extended\")</code></p> <ul> <li> <p><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Directory where the ICIO zip files are stored. It should normally include the trailing separator, e.g. <code>\"path/to/ICIO/raw/\"</code>.</p> </li> <li> <p><code>year</code> : <code>int</code>   Reference year of the ICIO/TiVA data to load. The function automatically selects the appropriate zip archive that contains this year, based on the OECD file naming convention (e.g. <code>ICIO-2016-2020-extended.zip</code>).</p> </li> <li> <p><code>typ</code> : <code>{\"small\", \"extended\"}</code>, default <code>\"extended\"</code>   Layout/type of the ICIO table:</p> </li> <li><code>\"small\"</code>: \u201csmall\u201d ICIO layout (fewer regions/sectors or more aggregated structure).</li> <li><code>\"extended\"</code>: \u201cextended\u201d ICIO layout (more regions/sectors, split entries for MEX/CHN, etc.).</li> </ul> <p>Details</p> <p>The function proceeds in several steps:</p> <ol> <li>Select the ICIO zip archive    ICIO releases are grouped into 5-year zip archives. Given <code>year</code> and <code>typ</code>, the function determines which file to use:</li> <li><code>ICIO-1995-2000-{typ}.zip</code></li> <li><code>ICIO-2001-2005-{typ}.zip</code></li> <li><code>ICIO-2006-2010-{typ}.zip</code></li> <li><code>ICIO-2011-2015-{typ}.zip</code></li> <li> <p><code>ICIO-2016-2020-{typ}.zip</code></p> </li> <li> <p>Read the CSV from inside the zip    The zip file is opened with <code>zipfile.ZipFile</code> and the appropriate CSV is read with <code>pandas.read_csv</code>:</p> </li> <li>For <code>typ=\"small\"</code>: the file is named <code>{year}_SML.csv</code>.</li> <li> <p>For <code>typ=\"extended\"</code>: the file is named <code>{year}.CSV</code>.    The first column is used as index (<code>index_col=0</code>), and the index name is reset (<code>df.index.name = None</code>) to avoid issues in later operations.</p> </li> <li> <p>Check and reconstruct the <code>\"OUT\"</code> column    Some ICIO releases do not contain a valid <code>\"OUT\"</code> column. The function:</p> </li> <li>Compares the sum of all elements with the value of the last column\u2019s first element.</li> <li> <p>If the test suggests that <code>\"OUT\"</code> is missing or incorrect, the function creates/overwrites <code>\"OUT\"</code> as the row sum across all columns: <code>df[\"OUT\"] = df.sum()</code></p> </li> <li> <p>Infer sectors (S) and final-demand components (FD)    Using a reference country (<code>ref = \"USA\"</code>), the function infers:</p> </li> <li><code>S</code>: number of sectors per country, as:      <pre><code>S = int(df.T.filter(like=\"USA\").shape[1])\n</code></pre></li> <li><code>SplusFD</code>: total number of columns (sectors + final demand) corresponding to <code>\"USA\"</code>:      <pre><code>SplusFD = int(df.filter(like=\"USA\").shape[1])\n</code></pre></li> <li> <p><code>FD = SplusFD - S</code>: number of final-demand columns per country.</p> </li> <li> <p>Collapse split entries for MEX and CHN (extended layout)    For <code>typ=\"extended\"</code>, the ICIO table splits Mexico and China into <code>MX1</code>/<code>MX2</code> and <code>CN1</code>/<code>CN2</code>. The nested helper function: <code>def mex_chn(df, MEX, MX1, MX2)</code>: Takes a DataFrame (df) and three codes (e.g. \"MEX\", \"MX1\", \"MX2\"). Sums the blocks corresponding to MEX, MX1 and MX2 over the sectoral columns. Replaces the main country\u2019s block (MEX) with that sum. Drops all columns containing MX1 and MX2. This is applied:</p> </li> </ol> <p>First to columns (destinations): MEX, then CHN.</p> <p>Then to the transposed DataFrame (rows/origins): again MEX and CHN. Finally, the table is transposed back to its original orientation.</p> <p>Compute number of countries and related dimensions The ICIO layout typically contains a few \u201cextra\u201d rows beyond country\u2013sector rows, for example:</p> <ul> <li>TLS (total intermediate use),</li> <li>VA (value added),</li> <li>OUT (total output).</li> </ul> <p>The code assumes filas_adic = 3 such additional rows. Then:</p> <ul> <li>C = (number_of_rows - filas_adic) / S: number of countries.</li> <li>CS = C \u00d7 S: total number of country\u2013sector combinations.</li> <li>CFD = C \u00d7 FD: total number of country\u2013final-demand combinations.</li> </ul> <p>Returns</p> <p>The function returns a dictionary with: - The full cleaned ICIO table (df), including extra rows such as TLS, VA, OUT. - The inferred dimensions (C, S, FD, CS, CFD), which are required for subsequent MRIO/ICIO operations (e.g. decomposition into value-added components).</p> <p>dict with the following keys:</p> <ul> <li>\"df\" : pandas.DataFrame   ICIO matrix with:</li> <li>Rows: country\u2013sector rows plus additional rows such as TLS, VA, and OUT.</li> <li>Columns: all country\u2013sector intermediate-use blocks, final-demand columns, and (if present or reconstructed) an \"OUT\" column for total output.</li> <li>\"C\" : int Number of countries in the ICIO.</li> <li>\"S\" : int Number of sectors per country.</li> <li>\"FD\" : int Number of final-demand components per country.</li> <li>\"CS\" : int Total number of country\u2013sector combinations (C \u00d7 S).</li> <li>\"CFD\" : int Total number of country\u2013final-demand combinations (C \u00d7 FD).</li> </ul> <p>Example</p> <pre><code>from intrade import load_TIVA\n\n# Directory where ICIO zip files are stored\nicio_dir = \"/path/to/ICIO/raw/\"\n\n# Example 1: Extended ICIO layout, year 2015\ntiva_ext_2015 = load_TIVA(dire=icio_dir, year=2015, typ=\"extended\")\n\ndf_ext  = tiva_ext_2015[\"df\"]\nC_ext   = tiva_ext_2015[\"C\"]\nS_ext   = tiva_ext_2015[\"S\"]\nFD_ext  = tiva_ext_2015[\"FD\"]\n\n# Example 2: Small ICIO layout, year 2018\ntiva_small_2018 = load_TIVA(dire=icio_dir, year=2018, typ=\"small\")\n\ndf_sml  = tiva_small_2018[\"df\"]\nC_sml   = tiva_small_2018[\"C\"]\nS_sml   = tiva_small_2018[\"S\"]\n\n# The returned df can be passed to downstream routines,\n# e.g. to build a WIO structure or perform value-added decompositions.\n</code></pre> <p>Notes</p> <p>Two types of tables are provided: small and extended. The small tables are distributed as ICIO-PERIOD-small.zip, and the extended tables as ICIO-PERIOD-extended.zip, where PERIOD refers to the five-year intervals 1995\u20132000, 2001\u20132005, 2006\u20132010, 2011\u20132015, and 2016\u20132020.</p> <p>Within each small archive, annual files are provided as 1995_SML.csv through 2020_SML.csv. Within each extended archive, the corresponding annual files are named 1995.csv through 2020.csv.</p>"},{"location":"load_wiod/","title":"load_WIOD","text":""},{"location":"load_wiod/#load_wiod","title":"load_WIOD","text":"<p>Description</p> <p><code>load_WIOD</code> reads a WIOD inter-country input\u2013output (WIOT) table for a given year and infers the main MRIO dimensions:</p> <ul> <li>number of countries/regions,</li> <li>number of sectors per country,</li> <li>number of final-demand components per country,</li> <li>and the derived country\u2013sector and country\u2013final-demand dimensions.</li> </ul> <p>The function is currently implemented for the WIOD 2016 release in Stata (<code>.dta</code>) format, using the ROW-extended tables (<code>*_ROW.dta</code>). It:</p> <ol> <li>Reads the WIOT for the requested year.</li> <li>Builds country\u2013sector row labels of the form <code>\"ISO3_sectorIndex\"</code> from the WIOD <code>Country</code> and <code>RNr</code> fields.</li> <li>Renames flow columns in a similar <code>\"ISO3_sectorIndex\"</code> style (e.g. <code>\"USA_1\"</code>, <code>\"DEU_5\"</code>).</li> <li>Uses a reference country (<code>USA</code>) to infer:</li> <li>sectors per country (<code>S</code>),</li> <li>final-demand components per country (<code>FD</code>),</li> <li>total countries (<code>C</code>),</li> <li>and the composite dimensions (<code>CS</code>, <code>CFD</code>).</li> </ol> <p>The result is a convenient dictionary containing both the IO table (<code>df</code>) and its basic structural dimensions.</p> <p>Usage</p> <p><code>load_WIOD(dire, year, typ)</code></p> <p>Arguments</p> <p><code>load_WIOD(dire, year, typ)</code></p> <ul> <li><code>dire</code> : <code>str</code> or <code>pathlib.Path</code>   Base directory where the WIOD files are stored. It must include the trailing separator, for example:   ```text   \"/path/to/WIOD/\" The function internally expects to find the Stata file in:</li> </ul> <p><code>dire + \"WIOD 2016\\\\WIOT{year}_October16_ROW.dta\"</code> year : int Reference year of the WIOT to load. For the WIOD 2016 release this typically covers 2000\u20132014 (plus some earlier/later years depending on the specific dataset).</p> <p>typ : {\"WIOD 2016\", \"WIOD 2013\", \"Long-run\"} Type of WIOD dataset. Currently, only:</p> <p><code>typ = \"WIOD 2016\"</code> is implemented in this function. Other values preserve the original behaviour (and will fail due to the absence of a defined df).</p> <p>Details</p> <ol> <li>Load WIOD 2016 table from Stata</li> </ol> <p>For <code>typ == \"WIOD 2016\"</code> the function reads the WIOT from a Stata file:</p> <p><code>df = pd.read_stata(dire + \"WIOD 2016\\\\WIOT\" + str(year) + \"_October16_ROW.dta\")</code></p> <p>The original WIOD 2016 WIOT*_ROW.dta file typically contains the following columns (among others):</p> <ul> <li>IndustryCode</li> <li>IndustryDescription</li> <li>Country (3-letter WIOD country code, ISO3-like)</li> <li>RNr (row number, used to distinguish sectors/rows)</li> <li>Year</li> <li> <p>vXXXYY columns for flows (e.g. vUSA01, vDEU12, \u2026) and final demand.</p> </li> <li> <p>Build the row index</p> </li> </ul> <p>The row index is constructed as: <code>df = df.set_index(df[\"Country\"] + \"_\" + df[\"RNr\"].astype(str))</code> giving labels such as:</p> <p>\"USA_1\", \"USA_2\", \u2026, \"DEU_1\", \"DEU_2\", \u2026</p> <p>This index approximates country\u2013sector accounts, with RNr representing the sector index within each country.</p> <ol> <li>Drop metadata / non-flow columns</li> </ol> <p>The following metadata columns are removed from the IO matrix: <code>df = df.drop(columns=[\"IndustryCode\", \"IndustryDescription\", \"Country\", \"RNr\", \"Year\"])</code></p> <p>The remaining columns correspond to flows (intermediate and final demand), usually prefixed with \"v\".</p> <ol> <li>Clean column names and convert them to \"ISO3_sectorIndex\"</li> </ol> <p>WIOD 2016 uses column names like \"vUSA01\", \"vDEU12\", etc. The function:</p> <p>Removes the leading 'v' (if present): <code>df = df.rename(columns=lambda x: x[1:] if isinstance(x, str) and x.startswith(\"v\")else x)</code></p> <ol> <li> <p>Splits them into \"ISO3_sectorIndex\" using:<code>df.columns = [col[:3] + \"_\" + col[3:] for col in df.columns]</code> So:</p> </li> <li> <p>\"vUSA01\" \u2192 \"USA01\" \u2192 \"USA_01\",</p> </li> <li> <p>\"vDEU14\" \u2192 \"DEU14\" \u2192 \"DEU_14\", etc.</p> </li> </ol> <p>This ensures that both rows and columns follow a country\u2013sector index pattern, facilitating subsequent processing into WIO structures.</p> <ol> <li>Infer number of sectors (S) and final-demand components (FD)</li> </ol> <p>A reference country (ref = \"USA\") is used to infer structural dimensions:</p> <ul> <li>Number of sectors S</li> <li>Count how many rows belong to USA when looking across origin-side sectors: <code>S = int(df.T.filter(like=\"USA\").shape[1])</code></li> <li>Total columns for USA (sectors + FD)</li> <li>Count how many columns correspond to USA: <code>SplusFD = int(df.filter(like=\"USA\").shape[1])</code></li> <li> <p>FD = SplusFD - S . FD is the number of final-demand components per country.</p> </li> <li> <p>Account for additional rows (aggregates, totals, etc.)</p> </li> </ul> <p>WIOD IO tables include some extra rows that are not part of the country\u2013sector block (e.g. totals, adjustments). The function assumes: <code>filas_adic = 8</code> additional rows beyond the C \u00d7 S core.</p> <ol> <li>Compute number of countries and composite dimensions</li> </ol> <p>With: <code>n_rows = df.shape[0]</code> the number of countries is:</p> <p><pre><code>C   = (n_rows - filas_adic) / S\nCS  = C * S     # total country\u2013sector combinations\nCFD = C * FD    # total country\u2013final-demand combinations\n</code></pre> Basic checks are printed to the console: <code>print(\"Year:\", year, \"\\nFile:\", \"WIOD\\\\WIOT\" + str(year) + \"_October16_ROW\")</code> <code>print(\"\\n Num Countries\", C, \"\\n Num sect\", S, \"\\n Num components FD\", FD)</code></p> <ol> <li>The function returns a dictionary:</li> </ol> <p><pre><code>dic = {\n    \"df\": df,\n    \"C\": int(C),\n    \"S\": int(S),\n    \"FD\": int(FD),\n    \"CS\": int(CS),\n    \"CFD\": int(CFD),\n}\n</code></pre> which can be directly used to build a wio structure or to feed value-added decomposition routines.</p> <p>Returns</p> <p>dict with:</p> <ul> <li> <p>\"df\" : pandas.DataFrame   WIOD IO table with:</p> </li> <li> <p>Rows: country\u2013sector-like accounts, indexed as \"ISO3_sectorIndex\"   (plus ~8 additional rows for aggregates/totals).</p> </li> <li> <p>Columns: country\u2013sector blocks and final-demand columns, all named as \"ISO3_sectorIndex\" (e.g. \"USA_1\", \"DEU_5\", etc.).</p> </li> <li> <p>\"C\" : int Number of countries/regions in WIOD (including the rest-of-world entry, ROW).</p> </li> <li> <p>\"S\" : int Number of sectors per country.</p> </li> <li> <p>\"FD\" : int Number of final-demand components per country.</p> </li> <li> <p>\"CS\" : int Total number of country\u2013sector combinations (C \u00d7 S).</p> </li> <li> <p>\"CFD\" : int Total number of country\u2013final-demand combinations (C \u00d7 FD).</p> </li> </ul> <p>Example</p> <pre><code>from intrade import load_WIOD\n\n# Base directory where WIOD 2016 files are stored\nwiod_dir = \"D:/MRIO/WIOD/\"\n\n# Example 1: Load WIOD 2016 table for year 2010\nwiod_2010 = load_WIOD(dire=wiod_dir, year=2010, typ=\"WIOD 2016\")\n\ndf_wiod = wiod_2010[\"df\"]\nC       = wiod_2010[\"C\"]\nS       = wiod_2010[\"S\"]\nFD      = wiod_2010[\"FD\"]\n\nprint(df_wiod.shape)  # (rows, cols) including aggregates\n\n# Example 2: Extract only country\u2013sector rows (excluding extra rows)\nCS = wiod_2010[\"CS\"]\ndf_core = df_wiod.iloc[:CS, :]   # first C*S rows as core MRIO block\n\n# Example 3: Subset USA as exporter (rows starting with \"USA_\")\nusa_rows = [idx for idx in df_wiod.index if idx.startswith(\"USA_\")]\ndf_usa   = df_wiod.loc[usa_rows, :]\n\n# The resulting df_wiod can then be converted into a WIO dictionary:\n#   wio = make_wio_from_df(df_core, C=C, S=S, FD=FD)\n# and used for standard value-added export decompositions.\n</code></pre> <p>Notes</p> <p>Implemented using the WIOD 2016 release. The program reads the files WIOT2000_October16_ROW.dta ... to WIOT2014_October16_ROW.dta from the WIOTS_in_STATA.zip archive.</p>"},{"location":"obj_grav/","title":"obj_Grav","text":""},{"location":"obj_grav/#obj_grav","title":"obj_Grav","text":"<p>Description</p> <p>Build bilateral trade flows by exporter\u2013sector\u2013importer for gravity models.</p> <p>This function takes a harmonised MRIO dictionary (as returned by the loader functions and possibly processed by <code>obj_IO</code>) and aggregates both intermediate and final goods exports into a long-format DataFrame suitable for gravity estimation.</p> <p>For each exporter\u2013sector\u2013importer triplet <code>(i, k, n)</code>, it computes:</p> <ul> <li>exports of intermediate goods,</li> <li>exports of final goods,</li> <li>total exports (intermediate + final).</li> </ul> <p>Country and sector labels are parsed from the column/index structure (e.g. <code>\"USA_1\"</code>, <code>\"DEU_3\"</code>, <code>\"FRA_2\"</code>, \u2026).</p> <p>Usage</p> <p><code>obj_Grav(dic)</code></p> <p>Arguments</p> <ul> <li><code>dic</code> : <code>dict</code>   MRIO dictionary with at least:</li> <li><code>\"df\"</code>   : <code>pandas.DataFrame</code>     Harmonised IO table with:<ul> <li>rows   = <code>CS</code> country\u2013sector rows (<code>C \u00d7 S</code>),</li> <li>cols   = first <code>CS</code> columns for intermediate use (Z block),            next <code>CFD</code> columns for final demand (Yfd block),            optionally a last column with total output.</li> </ul> </li> <li><code>\"C\"</code>    : <code>int</code> \u2013 number of countries (<code>C</code>).</li> <li><code>\"S\"</code>    : <code>int</code> \u2013 number of sectors per country (<code>S</code>).</li> <li><code>\"FD\"</code>   : <code>int</code> \u2013 number of final demand categories per country (<code>FD</code>).</li> <li><code>\"CS\"</code>   : <code>int</code> \u2013 total country\u2013sector pairs (<code>C \u00d7 S</code>).</li> <li><code>\"CFD\"</code>  : <code>int</code> \u2013 total country\u2013final-demand pairs (<code>C \u00d7 FD</code>).</li> </ul> <p>Details</p> <p>The function assumes the following harmonised layout of <code>dic[\"df\"]</code>:</p> <ul> <li> <p>Rows:   <code>0 .. CS-1</code> correspond to country\u2013sector combinations,   labelled as strings <code>\"ISO3_sector\"</code> (e.g. <code>\"USA_1\"</code>, <code>\"DEU_3\"</code>).</p> </li> <li> <p>Columns:</p> </li> <li><code>0 .. CS-1</code> \u2192 intermediate input block <code>Z</code> (<code>CS \u00d7 CS</code>),</li> <li><code>CS .. CS+CFD-1</code> \u2192 detailed final demand block <code>Yfd</code> (<code>CS \u00d7 CFD</code>),</li> <li>Optional last column \u2192 total output (<code>OUT</code>).</li> </ul> <p>Steps:</p> <ol> <li>Intermediate goods exports (Z block)</li> <li>Extract <code>Z_block = df.iloc[:CS, :CS]</code>.</li> <li>Stack to long format via <code>stack()</code>, giving a Series indexed by      <code>(origin_row_label, destination_col_label)</code>.</li> <li>Parse both labels <code>\"ISO3_sector\"</code> into:<ul> <li>exporter country <code>i</code> (first 3 characters),</li> <li>exporter sector <code>k</code> (characters after <code>\"ISO3_\"</code>),</li> <li>importer country <code>n</code> (first 3 characters of destination label),</li> <li>destination sector <code>j</code> (ignored later).</li> </ul> </li> <li> <p>Group by <code>[\"i\", \"k\", \"n\"]</code> and sum over <code>j</code> to obtain intermediate exports      from exporter\u2013sector <code>(i,k)</code> to importer <code>n</code>.</p> </li> <li> <p>Final goods exports (Yfd block)</p> </li> <li>Extract <code>Yfd_block = df.iloc[:CS, CS:CS+CFD]</code>.</li> <li>Stack to long format, again resulting in a Series indexed by      <code>(origin_label, fd_destination_label)</code>.</li> <li>Parse labels into:<ul> <li>exporter <code>i</code> and sector <code>k</code> (from the row label),</li> <li>importer <code>n</code> and final-demand category <code>f</code> (from the column label).</li> </ul> </li> <li> <p>Group by <code>[\"i\", \"k\", \"n\"]</code> and sum over <code>f</code> to obtain total final-goods      exports from <code>(i,k)</code> to <code>n</code>.</p> </li> <li> <p>Combine intermediate and final exports</p> </li> <li>Merge the intermediate and final exports DataFrames on index      <code>(\"i\", \"k\", \"n\")</code>.</li> <li>Rename resulting columns:<ul> <li><code>\"interm\"</code> : exports of intermediates,</li> <li><code>\"final\"</code>  : exports of final goods.</li> </ul> </li> <li> <p>Compute <code>\"trade\" = interm + final</code>.</p> </li> <li> <p>Output format</p> </li> <li>Reset the index and rename dimensions to:<ul> <li><code>\"exporter\"</code> (i),</li> <li><code>\"sector\"</code> (k),</li> <li><code>\"importer\"</code> (n),</li> <li>plus <code>\"interm\"</code>, <code>\"final\"</code>, <code>\"trade\"</code>.</li> </ul> </li> </ol> <p>Returns</p> <ul> <li> <p><code>df_t</code> : <code>pandas.DataFrame</code>   Long-format DataFrame with one row per exporter\u2013sector\u2013importer triplet:</p> </li> <li> <p><code>\"exporter\"</code> : <code>str</code> \u2013 ISO3 code of exporting country <code>i</code>.</p> </li> <li><code>\"sector\"</code>   : <code>str</code> \u2013 sector index <code>k</code> (as string).</li> <li><code>\"importer\"</code> : <code>str</code> \u2013 ISO3 code of importing country <code>n</code>.</li> <li><code>\"interm\"</code>   : <code>float</code> \u2013 exports of intermediate goods from <code>(i,k)</code> to <code>n</code>.</li> <li><code>\"final\"</code>    : <code>float</code> \u2013 exports of final goods from <code>(i,k)</code> to <code>n</code>.</li> <li><code>\"trade\"</code>    : <code>float</code> \u2013 total exports from <code>(i,k)</code> to <code>n</code>                          (<code>interm + final</code>).</li> </ul> <p>Example</p> <pre><code>import pandas as pd\nfrom intrade import load_TIVA, obj_IO, obj_Grav\n\n# 1. Load and harmonise an MRIO (e.g. OECD ICIO/TiVA)\ntiva_dic = load_TIVA(dire=\"path/to/ICIO/raw/\", year=2018, typ=\"extended\")\n\n# 2. Optionally build the IO object (e.g. to get Z, Y, EXGR, ...)\nio_dic = obj_IO(tiva_dic)\n\n# 3. Build bilateral exporter\u2013sector\u2013importer trade flows\ndf_grav = obj_Grav(tiva_dic)  # or obj_Grav(io_dic) if you harmonise there\n\n# Inspect the resulting gravity-ready dataset\nprint(df_grav.head())\n\n# Typical columns\n#   exporter  sector  importer  interm    final    trade\n# 0      USA       1      DEU   ...       ...      ...\n</code></pre> <p>Notes</p>"},{"location":"obj_grav_panel/","title":"obj_Grav_panel","text":""},{"location":"obj_grav_panel/#obj_grav_panel","title":"obj_Grav_panel","text":"<p>Description</p> <p>Build a multi-year panel of bilateral trade flows for gravity estimation.</p> <p><code>obj_Grav_panel</code> iterates over a dictionary of MRIO dictionaries (one per year), applies <code>obj_Grav</code> to each of them, and stacks the resulting exporter\u2013sector\u2013importer cross-sections into a single long-format <code>pandas.DataFrame</code> with a <code>year</code> identifier.</p> <p>This is a convenience wrapper that makes it straightforward to move from a set of annual MRIO tables to a panel dataset that can be fed into panel gravity routines (e.g. <code>grav_panel</code>) after merging additional gravity covariates.</p> <p>Usage</p> <p><code>obj_Grav_panel(dicc)</code></p> <p>Arguments</p> <ul> <li><code>dicc</code> : <code>dict</code>   Dictionary of the form:   <code>{year_1: dic_1, year_2: dic_2, ...}</code>   where each <code>dic_t</code> is a harmonised MRIO dictionary suitable for <code>obj_Grav</code>   (i.e. contains at least: <code>\"df\", \"C\", \"S\", \"FD\", \"CS\", \"CFD\"</code>).</li> </ul> <p>Notes:   - Years can be <code>int</code> or <code>str</code> (they are stored as-is in the output column <code>year</code>).   - If you want years in chronological order, pass <code>dicc</code> already sorted by year     (or build it using an ordered insertion).</p> <p>Details</p> <p>For each <code>(year, dic_year)</code> pair in <code>dicc.items()</code>:</p> <ol> <li>Compute bilateral trade flows for that year:</li> <li> <p><code>df_t = obj_Grav(dic_year)</code>    which returns a long DataFrame with columns:    <code>exporter</code>, <code>sector</code>, <code>importer</code>, <code>interm</code>, <code>final</code>, <code>trade</code>.</p> </li> <li> <p>Add a time identifier:</p> </li> <li> <p><code>df_t[\"year\"] = year</code></p> </li> <li> <p>Append the year-specific DataFrame to a list.</p> </li> </ol> <p>Finally, all years are stacked with: <code>panel_df = pd.concat(panel_data, ignore_index=True)</code></p> <p>The function prints the current <code>year</code> while looping and confirms completion with <code>\"Gravity Panel Object Done!\"</code>.</p> <p>Returns</p> <ul> <li> <p><code>panel_df</code> : <code>pandas.DataFrame</code>   Long-format panel with one row per exporter\u2013sector\u2013importer\u2013year observation:</p> </li> <li> <p><code>\"exporter\"</code> : <code>str</code> \u2013 ISO3 code of exporting country.</p> </li> <li><code>\"sector\"</code>   : <code>str</code> \u2013 sector index.</li> <li><code>\"importer\"</code> : <code>str</code> \u2013 ISO3 code of importing country.</li> <li><code>\"interm\"</code>   : <code>float</code> \u2013 intermediate exports.</li> <li><code>\"final\"</code>    : <code>float</code> \u2013 final-goods exports.</li> <li><code>\"trade\"</code>    : <code>float</code> \u2013 total exports (<code>interm + final</code>).</li> <li><code>\"year\"</code>     : <code>int</code> or <code>str</code> \u2013 year identifier.</li> </ul> <p>Example</p> <pre><code>import pandas as pd\nfrom intrade import load_TIVA, obj_Grav, obj_Grav_panel, grav_panel\n\n# 1) Load several annual MRIO tables (example with OECD ICIO/TiVA)\nicio_dir = \"path/to/ICIO/raw/\"\n\ndicc = {\n    2016: load_TIVA(dire=icio_dir, year=2016, typ=\"extended\"),\n    2017: load_TIVA(dire=icio_dir, year=2017, typ=\"extended\"),\n    2018: load_TIVA(dire=icio_dir, year=2018, typ=\"extended\"),\n}\n\n# 2) Build panel of exporter\u2013sector\u2013importer trade flows\ndf_panel_trade = obj_Grav_panel(dicc)\n\nprint(df_panel_trade.head())\n# exporter  sector  importer   interm    final    trade   year\n# USA       1       DEU       ...       ...      ...     2016\n\n# 3) (Optional) Merge gravity covariates before estimation\n# df_cov should contain exporter, importer, year, and covariates like LN_DIST, CNTG, LANG, BRDR, ...\n# df_panel = df_panel_trade.merge(df_cov, on=[\"exporter\",\"importer\",\"year\"], how=\"left\")\n\n# 4) Estimate a panel PPML gravity model (after adding covariates)\n# out = grav_panel(data=df_panel, fe=[\"ey\",\"iy\"], ref_country=\"USA\", verbose=True)\n# print(out[\"results\"].summary())\n</code></pre> <pre><code>dicc = {2020: ddff20, 2021: ddff21}\n\npanel = obj_grav_panel(dicc)\n\nreturn panel_df\n</code></pre>"},{"location":"obj_io/","title":"obj_IO","text":""},{"location":"obj_io/#obj_io","title":"obj_IO","text":"<p>Description</p> <p>Build a complete input\u2013output (IO) object from a harmonised MRIO dictionary.</p> <p>This function takes the output of the loader functions (<code>load_ADB</code>, <code>load_TIVA</code>, <code>load_EORA</code>, <code>load_FIGARO</code>, <code>load_GLORIA</code>, <code>load_WIOD</code>, <code>load_Test</code>, \u2026), which provide a harmonised MRIO table and its dimensions, and constructs a set of NumPy arrays commonly used in IO-analysis and trade-in-value-added (TiVA) decompositions:</p> <ul> <li>Intermediate use and coefficients</li> <li><code>Z</code>, <code>Zd</code>, <code>Zm</code>  \u2013 intermediate input matrix and domestic/foreign splits.</li> <li><code>A</code>, <code>Ad</code>, <code>Am</code>  \u2013 technical coefficients matrix and domestic/foreign splits.</li> <li><code>B</code>, <code>Bd</code>, <code>Bm</code>  \u2013 global Leontief inverse and domestic/foreign splits.</li> <li> <p><code>L</code>             \u2013 local/domestic Leontief inverse based on <code>Ad</code>.</p> </li> <li> <p>Final demand</p> </li> <li><code>Y</code>             \u2013 final demand by destination country.</li> <li><code>Yd</code>, <code>Ym</code>      \u2013 domestic and foreign final demand.</li> <li> <p><code>Yfd</code>           \u2013 detailed final demand (country \u00d7 component).</p> </li> <li> <p>Value added and output</p> </li> <li><code>VA</code>            \u2013 value added in levels.</li> <li><code>X</code>             \u2013 gross output.</li> <li><code>V</code>             \u2013 value-added coefficients vector.</li> <li> <p><code>W</code>             \u2013 diagonal matrix of value-added coefficients.</p> </li> <li> <p>Exports</p> </li> <li><code>EXGR</code>          \u2013 gross bilateral exports (intermediates + final).</li> <li><code>E</code>             \u2013 diagonal matrix of total exports by country\u2013sector.</li> <li><code>Efd</code>           \u2013 exports of final goods.</li> <li><code>Eint</code>          \u2013 exports of intermediates.</li> <li><code>ESR</code>           \u2013 total exports (intermediate + final), by destination.</li> </ul> <p>In addition, it returns two metadata dictionaries: - <code>dims</code> with basic dimensions (<code>C</code>, <code>S</code>, <code>FD</code>, <code>CS</code>, <code>CFD</code>), - <code>names</code> with country, sector and final-demand labels.</p> <p>Usage</p> <p><code>obj_IO(dic)</code></p> <p>Arguments</p> <ul> <li><code>dic</code> : <code>dict</code>   Harmonised MRIO dictionary as returned by the loader functions, with at least:</li> <li><code>\"df\"</code>   : <code>pandas.DataFrame</code>     Input\u2013output table in harmonised format.     Rows: country\u2013sector (<code>CS = C \u00d7 S</code>).     Columns:<ol> <li>All intermediate-use blocks (<code>CS</code> columns)</li> <li>All final demand columns (<code>CFD</code> columns)</li> <li>One total output column</li> <li><code>\"C\"</code>    : <code>int</code> \u2013 number of countries/regions.</li> <li><code>\"S\"</code>    : <code>int</code> \u2013 number of sectors per country.</li> <li><code>\"FD\"</code>   : <code>int</code> \u2013 number of final-demand categories per country.</li> <li><code>\"CS\"</code>   : <code>int</code> \u2013 <code>C \u00d7 S</code>, total number of country\u2013sector pairs.</li> <li><code>\"CFD\"</code>  : <code>int</code> \u2013 <code>C \u00d7 FD</code>, total number of country\u2013final-demand pairs.</li> </ol> </li> </ul> <p>Details</p> <p>The function assumes that the MRIO dictionary has already been harmonised to a common layout:</p> <ul> <li>The intermediate-use block <code>Z</code> is taken as:</li> <li><code>Z = df.iloc[0:CS, 0:CS]</code> (shape <code>CS \u00d7 CS</code>).</li> <li>The detailed final demand matrix <code>Yfd</code> is taken as:</li> <li><code>Yfd = df.iloc[0:CS, CS:CS+CFD]</code> (shape <code>CS \u00d7 CFD</code>).</li> </ul> <p>From this, the function:</p> <ol> <li>Builds domestic/foreign selectors</li> </ol> <p>Using Kronecker products and ones matrices, it constructs:    - <code>block_diag1_CSxCS</code> : block-diagonal selector (domestic links),    - <code>block_diag0_CSxCS</code> : complement (foreign links),    - <code>block_diag1_CSxC</code>  : domestic selector for <code>CS \u00d7 C</code>,    - <code>block_diag0_CSxC</code>  : foreign selector for <code>CS \u00d7 C</code>.</p> <ol> <li>Extracts names and dimensions</li> </ol> <p>From the column labels (e.g. <code>\"USA_1\"</code>, <code>\"DEU_3\"</code>), it recovers:    - <code>c_names</code> : unique country codes (ISO3 or ISO3-like),    - <code>s_names</code> : sector indices (usually <code>\"1\"</code>, <code>\"2\"</code>, \u2026),    - <code>cs_names</code>: full country\u2013sector labels,    - from <code>Yfd</code>, the final-demand labels <code>fd_names</code> and <code>cfd_names</code>.</p> <ol> <li> <p>Computes value added and output</p> </li> <li> <p><code>VA</code> is computed as total uses (intermediate + final demand) minus intermediate uses.</p> </li> <li> <p><code>X</code> is the row sum of the intermediate + final-demand block, i.e. gross output.</p> </li> <li> <p>Constructs intermediate matrices</p> </li> <li> <p><code>Z</code> is converted to a NumPy array (<code>CS \u00d7 CS</code>).</p> </li> <li> <p>Domestic and foreign parts:</p> <ul> <li><code>Zd = Z * block_diag1_CSxCS</code></li> <li><code>Zm = Z * block_diag0_CSxCS</code></li> </ul> </li> <li> <p>Technical coefficients and Leontief inverses</p> </li> <li> <p>Builds <code>x_hat_inv = pinv(diag(X))</code> to handle zero outputs.</p> </li> <li>Technical coefficients:<ul> <li><code>A = Z @ x_hat_inv</code></li> <li><code>Ad = A * block_diag1_CSxCS</code></li> <li><code>Am = A * block_diag0_CSxCS</code></li> </ul> </li> <li> <p>Leontief inverses:</p> <ul> <li><code>L  = (I - Ad)^{-1}</code> (local/domestic)</li> <li><code>B  = (I - A)^{-1}</code>  (global)</li> <li><code>Bd = B * block_diag1_CSxCS</code></li> <li><code>Bm = B * block_diag0_CSxCS</code></li> </ul> </li> <li> <p>Final demand by country</p> </li> <li> <p>Aggregates <code>Yfd</code> by destination country, using the country code in the column labels:</p> <ul> <li><code>Y</code> is <code>CS \u00d7 C</code>, with column order matching <code>c_names</code>.</li> </ul> </li> <li> <p>Domestic and foreign splits:</p> <ul> <li><code>Yd = Y * block_diag1_CSxC</code></li> <li><code>Ym = Y * block_diag0_CSxC</code></li> </ul> </li> <li> <p>Value-added coefficients</p> </li> <li> <p>Computes WWZ-style value-added coefficients:</p> <ul> <li><code>V = [1' (I - A)]'</code> (shape <code>CS \u00d7 1</code>), cleaned of NaNs.</li> </ul> </li> <li> <p>Builds the diagonal matrix:</p> <ul> <li><code>W = diag(V)</code>.</li> </ul> </li> <li> <p>Gross bilateral exports</p> </li> <li> <p>Loops over country blocks to build:</p> <ul> <li><code>Zm_meld</code> (shape <code>CS \u00d7 C</code>): foreign intermediate exports by origin sector and destination country.</li> </ul> </li> <li>Gross bilateral exports:<ul> <li><code>EXGR = Zm_meld + Ym</code>  (intermediate + final exports).</li> </ul> </li> <li> <p>Total exports by country\u2013sector:</p> <ul> <li><code>E = diag(EXGR.sum(axis=1))</code>.</li> </ul> </li> <li> <p>Export decomposition: final vs intermediate</p> </li> <li> <p>Stacks <code>[Z | Y]</code> horizontally into <code>z</code> (shape <code>CS \u00d7 (CS + C)</code>).</p> </li> <li> <p>For each destination country:</p> <ul> <li><code>Efd</code> collects exports of final goods,</li> <li><code>Eint</code> collects exports of intermediates,</li> <li><code>ESR = Efd + Eint</code> is total exports.</li> </ul> </li> <li> <p>Metadata</p> <p>Finally, it stores: - <code>dims = {\"C\", \"S\", \"FD\", \"CS\", \"CFD}</code>, - <code>names = {\"c_names\", \"s_names\", \"fd_names\", \"cs_names\", \"cfd_names\"}</code>.</p> </li> </ol> <p>All arrays are NumPy <code>ndarray</code> objects; labels and dimensions are preserved in the <code>names</code> and <code>dims</code> dictionaries, respectively.</p> <p>Returns</p> <ul> <li> <p><code>io_dic</code> : <code>dict</code>   A dictionary with IO-related matrices and metadata:</p> </li> <li> <p>Intermediate use and coefficients:</p> <ul> <li><code>\"Z\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 intermediate inputs.</li> <li><code>\"Zd\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 domestic intermediate inputs.</li> <li><code>\"Zm\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 foreign intermediate inputs.</li> <li><code>\"A\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 technical coefficients.</li> <li><code>\"Ad\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 domestic coefficients.</li> <li><code>\"Am\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 foreign coefficients.</li> <li><code>\"B\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 global Leontief inverse.</li> <li><code>\"Bd\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 domestic part of <code>B</code>.</li> <li><code>\"Bm\"</code>  : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 foreign part of <code>B</code>.</li> <li><code>\"L\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>) \u2013 domestic Leontief inverse (<code>Ad</code>).</li> </ul> </li> <li> <p>Final demand:</p> <ul> <li><code>\"Y\"</code>   : <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 final demand by destination country.</li> <li><code>\"Yd\"</code>  : <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 domestic part of final demand.</li> <li><code>\"Ym\"</code>  : <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 foreign part of final demand.</li> <li><code>\"Yfd\"</code> : <code>ndarray</code> (<code>CS \u00d7 CFD</code>)     \u2013 detailed final demand by component.</li> </ul> </li> <li> <p>Value added and output:</p> <ul> <li><code>\"VA\"</code>  : <code>ndarray</code> (<code>CS \u00d7 1</code>)       \u2013 value added in levels.</li> <li><code>\"V\"</code>   : <code>ndarray</code> (<code>CS \u00d7 1</code>)       \u2013 value-added coefficients.</li> <li><code>\"W\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>)      \u2013 diagonal matrix of <code>V</code>.</li> <li><code>\"X\"</code>   : <code>ndarray</code> (<code>CS \u00d7 1</code>)       \u2013 gross output.</li> </ul> </li> <li> <p>Exports:</p> <ul> <li><code>\"EXGR\"</code>: <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 gross bilateral exports.</li> <li><code>\"E\"</code>   : <code>ndarray</code> (<code>CS \u00d7 CS</code>)      \u2013 diagonal total exports (<code>\u0112</code>).</li> <li><code>\"Efd\"</code> : <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 exports of final goods.</li> <li><code>\"Eint\"</code>: <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 exports of intermediates.</li> <li><code>\"ESR\"</code> : <code>ndarray</code> (<code>CS \u00d7 C</code>)       \u2013 total exports (intermediate + final).</li> </ul> </li> <li> <p>Metadata:</p> <ul> <li><code>\"dims\"</code>  : <code>dict</code> with keys <code>\"C\"</code>, <code>\"S\"</code>, <code>\"FD\"</code>, <code>\"CS\"</code>, <code>\"CFD\"</code>.</li> <li><code>\"names\"</code> : <code>dict</code> with keys <code>\"c_names\"</code>, <code>\"s_names\"</code>, <code>\"fd_names\"</code>, <code>\"cs_names\"</code>, <code>\"cfd_names\"</code>.</li> </ul> </li> </ul> <p>Example</p> <pre><code>import pandas as pd\nfrom intrade import load_TIVA, obj_IO   # example import\n\n# 1. Load and harmonise an ICIO/TiVA table (e.g. OECD ICIO extended 2018)\ntiva_dic = load_TIVA(dire=\"path/to/ICIO/raw/\", year=2018, typ=\"extended\")\n\n# `tiva_dic` contains:\n#   - \"df\": harmonised IO DataFrame\n#   - \"C\", \"S\", \"FD\", \"CS\", \"CFD\": dimensions\n\n# 2. Build the full IO object\nio_dic = obj_IO(tiva_dic)\n\n# 3. Access standard matrices for further analysis\nZ   = io_dic[\"Z\"]     # intermediate inputs\nA   = io_dic[\"A\"]     # technical coefficients\nB   = io_dic[\"B\"]     # Leontief inverse\nY   = io_dic[\"Y\"]     # final demand by country\nEXGR = io_dic[\"EXGR\"] # gross bilateral exports\nV   = io_dic[\"V\"]     # value-added coefficients\n\n# 4. Use dimensions and labels\nC    = io_dic[\"dims\"][\"C\"]\nS    = io_dic[\"dims\"][\"S\"]\ncids = io_dic[\"names\"][\"c_names\"]\nsids = io_dic[\"names\"][\"s_names\"]\n</code></pre>"},{"location":"solve_system_Ti/","title":"solve_system_Ti","text":""},{"location":"solve_system_Ti/#solve_system_ti","title":"solve_system_Ti","text":"<p>Description</p> <p>Equilibrium system for exact-hat algebra.</p> <p><code>solve_system_Ti</code> implements the system of equilibrium conditions used in the exact-hat algebra solution of the structural gravity model under trade imbalances.</p> <p>It is designed to be used with a root-finding algorithm such as scipy.optimize.root, and is called inside <code>struc_grav_cf</code>.</p> <p>Usage</p> <p><code>solve_system_Ti(x, T_ratio, q, TI, pi, sigma)</code></p> <p>Arguments</p> <ul> <li> <p><code>x</code> (ndarray, shape (n,)) : Vector of unknown \"hats\" (e.g., output and prices), typically initialised at ones.</p> </li> <li> <p><code>T_ratio</code> (ndarray, shape (n, n)) : Matrix of trade cost ratios between counterfactual and baseline, raised to the appropriate power.</p> </li> <li> <p><code>q</code> (ndarray, shape (n,)) : Vector of baseline output (or expenditure).</p> </li> <li> <p><code>TI</code> (ndarray, shape (n,)) : Vector of trade imbalances.</p> </li> <li> <p><code>pi</code> (ndarray, shape (n, n)) : Matrix of baseline expenditure shares.</p> </li> <li> <p><code>sigma</code> (float) : Elasticity of substitution.</p> </li> </ul> <p>Details</p> <p>The function computes a vector of residuals <code>F</code> such that <code>F = 0</code> characterises the equilibrium of the counterfactual economy (market clearance + consistency with trade imbalances and shares).</p> <p>It is structured so that:</p> <ul> <li>The first $n-1$ equations impose the equilibrium conditions for all countries except the num\u00e9raire.</li> <li>The last equation pins down the scale (e.g., normalisation of one hat).</li> </ul> <p>The exact algebra matches the functional form of the structural gravity model and the implementation of <code>struc_grav_cf</code>.</p> <p>Value</p> <p><code>F</code> (ndarray, shape (n,)) : Vector of residuals; the equilibrium is obtained when <code>F</code> is (approximately) the zero vector.</p> <p>Example</p> <pre><code>from scipy import optimize\nfrom intrade import solve_system_Ti\n\nn = T_ratio.shape[0]\nx0 = np.ones(n)\n\nsol = optimize.root(\n    solve_system_Ti,\n    x0,\n    args=(T_ratio, q, TI, pi, sigma),\n    method='df-sane',\n)\n\nx_hat = sol.x\n</code></pre> <p>\\cleardoublepage \\phantomsection \\addcontentsline{toc}{chapter}{Index} \\printindex</p>"},{"location":"stream/","title":"stream","text":""},{"location":"stream/#stream","title":"stream","text":"<p>Description</p> <p>Computes upstream and downstream indices for each country\u2013sector in a world input\u2013output (WIO) table.</p> <p>The function uses the foreign-use technical coefficients matrix and gross output to quantify:</p> <p>how downstream a country\u2013sector is in the global value chain (how many further production stages it feeds into), and</p> <p>how upstream it is (how many upstream stages are embodied in its own production).</p> <p>These indices are based on Leontief-type formulas of the form: $$(I - A)^{-1}\\,\\mathbf{1}$$</p> <p>applied to the foreign part of the technical coefficients.</p> <p>Usage</p> <p><code>stream(wio)</code></p> <p>Arguments</p> <ul> <li> <p>wio (dict) Input\u2013output object, typically created by obj_IO, with at least:</p> </li> <li> <p>wio[\"Am\"] : np.ndarray of shape (CS, CS) Foreign-use technical coefficients matrix (off-diagonal part of A).</p> </li> <li> <p>wio[\"X\"] : np.ndarray of length CS Gross output by country\u2013sector (levels).</p> </li> <li> <p>wio[\"dims\"][\"CS\"] : int Total number of country\u2013sector combinations (CS = C \u00d7 S).</p> </li> <li> <p>wio[\"names\"][\"cs_names\"] : array-like of length CS Labels for country\u2013sector rows/columns, e.g. \"USA_1\", \"DEU_3\", \u2026</p> </li> </ul> <p>Details</p> <p>For each country\u2013sector (indexed 1,\u2026,CS), the function constructs two scalar indices:</p> <ol> <li>Downstream index (down)</li> </ol> <p>Defined as:</p> <p>$$ \\text{down} \\;=\\; \\bigl(I - A_m^{\\top}\\bigr)^{-1}\\,\\mathbf{1}, $$</p> <p>where:</p> <ul> <li>$A_m$  is the foreign-use technical coefficients matrix (Am),</li> <li>$A_m^{\\top}$ is its transpose,</li> <li>$I$ is the identity matrix of size CS \u00d7 CS,</li> <li>$1$ is a CS \u00d7 1 vector of ones.</li> </ul> <p>-Intuition-: this measures how much further production (downstream uses) is triggered by one extra unit across the whole system via foreign linkages.</p> <ol> <li>Upstream index (up)</li> </ol> <p>First builds a scaled version of $A_m^\\top$  using output X:</p> <ul> <li> <p>Let X be the gross output vector (length CS).</p> </li> <li> <p>A row-normalised variant of $A_m^\\top$  is constructed as:</p> </li> </ul> <p>$$ A_{\\text{scaled}} \\;=\\; \\frac{\\bigl(A_m^\\top \\odot X\\bigr)^\\top}{X + \\varepsilon}, $$</p> <p>where a small $\\varepsilon$ = 1e-10 avoids division by zero and any resulting NaNs are replaced by zero.</p> <p>The upstream index is then:</p> <p>$$\\text{up} = (I - A_{\\text{scaled}})^{-1}\\,\\mathbf{1}$$</p> <p>Intuition: this captures how many upstream stages (foreign-sourced links) are embodied in the production of each country\u2013sector, after normalising by its own scale of output.</p> <p>Computation steps:</p> <ol> <li> <p>Extract Am, X, CS and cs_names from wio and perform basic shape checks.</p> </li> <li> <p>Build the identity matrix I of size CS \u00d7 CS.</p> </li> <li> <p>Compute the downstream index: result_down = solve(I - Am.T, 1).</p> </li> <li> <p>Construct a scaled version of Am.T using X, remove any NaNs, and compute the upstream index: result_up = solve(I - A_transposed_scaled, 1).</p> </li> <li> <p>Wrap the results into a pandas.DataFrame with index cs_names and columns \"up\" and \"down\".</p> </li> </ol> <p>Returns</p> <p>result (pandas.DataFrame)</p> <p>A DataFrame with one row per country\u2013sector and two columns:</p> <p>Index:   - cs_names (e.g. \"USA_1\", \"DEU_5\", \"CHN_12\", \u2026).</p> <p>Columns:</p> <ul> <li> <p>\"up\"   Upstream stream index for each country\u2013sector (higher values indicate a more upstream position through foreign linkages).</p> </li> <li> <p>\"down\"   Downstream stream index for each country\u2013sector (higher values indicate a more downstream position, feeding many additional stages).</p> </li> </ul> <p>Example</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom intrade import load_TIVA, obj_IO, stream\n\n# 1. Load an ICIO/TiVA table and build the IO object\ntiva_dic = load_TIVA(dire=\"/path/to/ICIO/\", year=2015, typ=\"extended\")\nwio = obj_IO(tiva_dic)\n\n# 2. Compute upstream and downstream indices\nsd = stream(wio)\n\n# 3. Inspect a few country\u2013sectors\nprint(sd.head())\n\n# 4. Example: sort sectors by downstreamness in Germany\nsd_DEU = sd[sd.index.str.startswith(\"DEU_\")].sort_values(\"down\", ascending=False)\nprint(sd_DEU.head())\n</code></pre>"},{"location":"struc_grav_asif/","title":"struc_grav_asif","text":""},{"location":"struc_grav_asif/#struc_grav_asif","title":"struc_grav_asif","text":"<p>Description</p> <p>\u201cAs-if\u201d FTA counterfactual</p> <p><code>struc_grav_asif</code> is a wrapper around <code>struc_grav_cf</code> for scenarios where a country (or group) is made to have the same trade cost treatment as another group vis-\u00e0-vis a reference group (e.g. UK \u201cas if\u201d it were in the EU for FTA purposes).</p> <p>Usage</p> <p><code>struc_grav_asif(     data,     variables,     countries1,     countries2,     countries3,     ref_country,     sigma=7.0,     verbose=True, )</code></p> <p>Arguments</p> <p>Same as <code>struc_grav_incre</code>, but with an additional group <code>countries3</code> used to define the \"benchmark\" FTA treatment.</p> <p>Value</p> <p>Same structure as <code>struc_grav_incre</code> (country-level percentage changes).</p> <p>Example</p> <pre><code># Example: UK treated \"as if\" it had the same FTA status as Norway vis-\u00e0-vis the EU\n\n# Reference group (e.g. EU27)\nEU = [\n    \"AUT\",\"BEL\",\"BGR\",\"HRV\",\"CYP\",\"CZE\",\"DNK\",\"EST\",\"FIN\",\"FRA\",\n    \"DEU\",\"GRC\",\"HUN\",\"IRL\",\"ITA\",\"LVA\",\"LTU\",\"LUX\",\"MLT\",\"NLD\",\n    \"POL\",\"PRT\",\"ROU\",\"SVK\",\"SVN\",\"ESP\",\"SWE\"\n]\n\n# Benchmark FTA partner with the EU (e.g. Norway in the EEA)\nEFTA_NOR = [\"NOR\"]\n\n# Country (or group) we want to treat \"as if\" it had the same FTA treatment\nUK = [\"GBR\"]\n\nres_asif = struc_grav_asif(\n    data=df,                               # bilateral trade + gravity covariates\n    variables=[\"LN_DIST\", \"CNTG\", \"LANG\", \"BRDR\"],\n    countries1=EU,                         # reference group (EU)\n    countries2=UK,                         # country to be treated \"as if\"\n    countries3=EFTA_NOR,                  # benchmark FTA treatment (Norway\u2013EU)\n    ref_country=\"DEU\",                     # reference importer for fixed effects\n    sigma=7.0,\n    verbose=True,\n)\n\n# 'res_asif' is a country-level summary with Export%, Real_Income%, etc.\nprint(res_asif)\n</code></pre>"},{"location":"struc_grav_cf/","title":"struc_grav_cf","text":""},{"location":"struc_grav_cf/#struc_grav_cf","title":"struc_grav_cf","text":"<p>Description</p> <p>struc_grav_cf estimates a structural gravity model with PPML and performs a general-equilibrium counterfactual analysis using exact hat algebra.</p> <p>The function:</p> <ol> <li> <p>Estimates a baseline PPML gravity equation with exporter and importer fixed effects and standard gravity covariates.</p> </li> <li> <p>Reconstructs baseline bilateral trade and multilateral resistance terms.</p> </li> <li> <p>Builds a counterfactual trade-cost matrix depending on the scenario (selection).</p> </li> <li> <p>Solves the general-equilibrium counterfactual system using an external solver (solve_system_Ti).</p> </li> <li> <p>Returns country-level percentage changes in exports, real income, output and consumption prices.</p> </li> </ol> <p>It is designed to implement counterfactual exercises such as increases in bilateral trade costs, \u201cas if\u201d FTA scenarios, or changes in RTA membership.</p> <p>Usage</p> <p><code>struc_grav_cf(data: pd.DataFrame, variables: list[str], countries1: list[str], countries2: list[str], countries3: list[str], ref_country: str, increase: float = 0.0, selection: int = 1, sigma: float = 7.0, verbose: bool = True,)</code></p> <p>Arguments</p> <ul> <li> <p>data (pandas.DataFrame) Bilateral trade dataset in long format. Must contain at least the following columns:</p> </li> <li> <p>exporter \u2013 exporter country code (e.g. ISO3).</p> </li> <li> <p>importer \u2013 importer country code.</p> </li> <li> <p>trade \u2013 bilateral exports from exporter to importer.   It must also include all gravity covariates listed in variables (e.g. distance, contiguity, common language, border).</p> </li> <li> <p>variables (list[str]) List of baseline gravity covariates to be included linearly in the PPML regression. Typical example: ['LN_DIST', 'CNTG', 'LANG', 'BRDR']</p> </li> </ul> <p>Additional dummies for the counterfactual scenario are constructed internally and appended to this list.</p> <ul> <li> <p>countries1 (list[str]) First group of countries used to define the counterfactual:</p> </li> <li> <p>For selection = 1: countries whose trade costs increase against countries2.</p> </li> <li> <p>For selection = 2: reference group in the \u201cas if\u201d FTA scenario.</p> </li> <li> <p>For selection = 3: base RTA membership group.</p> </li> <li> <p>countries2 (list[str]) Second group of countries used for the counterfactual:</p> </li> <li> <p>For selection = 1: partner group against which trade costs for countries1 increase.</p> </li> <li> <p>For selection = 2: first comparison group in the \u201cas if\u201d FTA scenario.</p> </li> <li> <p>For selection = 3: the country potentially entering or exiting the RTA (only countries2[0] is used).</p> </li> <li> <p>countries3 (list[str]) Third group of countries, only used when selection = 2:</p> </li> <li> <p>For selection = 2: second comparison group in the \u201cas if\u201d FTA scenario.</p> </li> <li> <p>Ignored for selection = 1 and selection = 3.</p> </li> <li> <p>ref_country (str) Reference importer for importer fixed effects. The dummy imp_fe_ref_country is dropped from the regression to avoid collinearity. Must match one of the country codes appearing in importer.</p> </li> <li> <p>increase (float, default 0.0) Percentage increase in trade costs for the special bilateral relations defined by (countries1, countries2) when selection = 1. Ignored for selection = 2 and selection = 3.</p> </li> <li> <p>selection (int, default 1) Type of counterfactual experiment:</p> </li> <li> <p>1 \u2013 Trade-cost increase between countries1 and countries2.   A special dummy BRDR_{len(countries1)}{countries2[0]} is created and its coefficient is scaled by (1 + increase/100) in the counterfactual.</p> </li> <li> <p>2 \u2013 \u201cAs if\u201d FTA scenario.   Two dummies are created:</p> <p>sh_{countries2[0]}_FTA</p> <p>sh_{countries3[0]}_FTA   to mimic different FTA treatment of countries2 and countries3 vis-\u00e0-vis countries1.</p> </li> <li> <p>3 \u2013 RTA entry/exit.   An RTA dummy is defined among countries1 (excluding domestic flows) and copied to FTA. Then countries2[0] is made to enter or exit this RTA in the counterfactual.</p> </li> <li> <p>sigma (float, default 7.0) Elasticity of substitution in the CES demand structure. It affects the exact-hat algebra and the construction of the trade-cost ratio matrix (T_cf / T_bsln)^(1/(1 - sigma)).</p> </li> <li> <p>verbose (bool, default True) If True, prints:</p> </li> <li> <p>PPML regression summary,</p> </li> <li> <p>basic checks for equality between observed and predicted total trade,</p> </li> <li> <p>equilibrium consistency checks for the counterfactual (q_c, E_c, etc.),</p> </li> <li> <p>and the final country-level summary.</p> </li> </ul> <p>Details</p> <p>The function proceeds in several steps:</p> <ol> <li> <p>Input checks</p> </li> <li> <p>Works on a copy of data (the original DataFrame is not modified).</p> </li> <li> <p>Verifies that all countries listed in countries1, countries2, countries3 appear in at least one of exporter or importer. If any code is missing, a ValueError is raised listing the missing countries.</p> </li> <li> <p>Baseline variables and fixed effects</p> </li> <li> <p>Constructs a border dummy BRDR (1 = international, 0 = domestic).</p> </li> <li> <p>Computes:</p> </li> <li> <p>output \u2013 total exports by country: sum(trade) over exporter.</p> </li> <li> <p>expndr \u2013 total expenditure by country: sum(trade) over importer.</p> </li> <li> <p>Creates exporter and importer fixed effects using dummy variables:</p> </li> <li> <p>exp_fe_XXX for each exporter.</p> </li> <li> <p>imp_fe_XXX for each importer.</p> </li> <li> <p>Computes an additional parameter phi only for intra-national flows:</p> </li> <li> <p>phi = expndr / output</p> </li> </ol> <p>for pairs where exporter == importer.</p> <ul> <li>Scenario-specific dummies (selection)</li> </ul> <p>selection = 1   Defines:   - BRDR_{len(countries1)}{countries2[0]} equal to 1 when trade is between countries1 and countries2 (in either direction).   This dummy is then subtracted from the common border dummy BRDR so that its effect is captured separately.</p> <p>selection = 2 (\u201cas if\u201d FTA scenario)   Defines:</p> <ul> <li> <p>sh_{countries2[0]}_FTA = 1 if trade between countries1 and countries2,</p> </li> <li> <p>sh_{countries3[0]}_FTA = 1 if trade between countries1 and countries3.</p> </li> <li> <p>Both dummies are subtracted from BRDR to avoid double counting.</p> </li> </ul> <p>selection = 3 (RTA entry/exit)</p> <ul> <li> <p>Constructs RTA = 1 for international flows within countries1.</p> </li> <li> <p>Sets FTA = RTA.</p> </li> </ul> <p>-In the counterfactual, countries2[0] is either added to or removed from the RTA membership when building the NRTA dummy.</p> <p>In all cases, the list columns_names combines the baseline variables in variables with the additional scenario-specific dummies that enter the PPML equation.</p> <ol> <li> <p>PPML estimation</p> <p>Selects all exporter FE dummies (^exp_fe_) and all importer FE dummies (^imp_fe_), dropping the importer FE for ref_country.</p> </li> </ol> <p>Builds the regressor matrix:</p> <pre><code>X = data[columns_names + exp_fe_cols + imp_fe_cols]\ny = data[\"trade\"]\n</code></pre> <p>Estimates a Poisson GLM with robust (HC3) standard errors:</p> <pre><code>model = sm.GLM(y, X, family=sm.families.Poisson())\nresults = model.fit(cov_type=\"HC3\")\n</code></pre> <ol> <li> <p>Baseline reconstruction (BLN)</p> <p>Multiplies each exporter FE dummy exp_fe_i by exp($\\beta$_exp_fe_i) and each importer FE dummy imp_fe_j (except ref_country) by exp($\\beta$_imp_fe_j).</p> </li> </ol> <p>Sums all exporter FEs and importer FEs:</p> <pre><code>all_exp_fes_0 = sum(exp_fe_*)\nall_imp_fes_0 = sum(imp_fe_*)\n</code></pre> <p>Reconstructs bilateral trade-cost indices in levels:</p> <pre><code>t_ij_BLN = exp( $\\sum$ $\\beta$_k * X_k )\n</code></pre> <p>over all covariates in columns_names.</p> <p>Sets:</p> <pre><code>output_BLN = output\nexpndr_BLN = expndr\n</code></pre> <p>Chooses expndr_ref as the mean expenditure of the reference importer (ref_country), and constructs outward and inward multilateral resistances:</p> <pre><code>omr_BLN = output_BLN * expndr_ref / all_exp_fes_0\nimr_BLN = expndr_BLN / (all_imp_fes_0 * expndr_ref)\n</code></pre> <p>Predicted baseline trade is:</p> <pre><code>trade_BLN = output_BLN * expndr_BLN * t_ij_BLN / (imr_BLN * omr_BLN)\n</code></pre> <p>When verbose=True, it checks that the sum of observed and predicted trade differ by less than 0.1% and prints a warning otherwise.</p> <p>Counterfactual trade costs Depending on selection, the counterfactual trade-cost matrix t_ij_CFL is constructed as:</p> <p>Selection 1 (trade-cost increase):</p> <pre><code># special is the scenario dummy (last in columns_names)\n\n\n        t_ij_CFL = np.exp(\n            sum(\n                params.loc[var, \"beta_hat\"] * data[var]\n                for var in columns_names[:-1]\n            )\n            + (1 + increase / 100.0)\n            * params.loc[special, \"beta_hat\"]\n            * data[special]\n        )\n</code></pre> <p>Selection 2 (\u201cas if\u201d FTA): the coefficient for sh_{countries3[0]}_FTA is used and applied to both FTA dummies.</p> <p>Selection 3 (RTA entry/exit): RTA membership is modified via NRTA, and:</p> <pre><code>        t_ij_CFL = np.exp(\n            sum(params.loc[var, \"beta_hat\"] * data[var] for var in variables)\n            + params.loc[\"FTA\", \"beta_hat\"] * data[\"FTA\"]\n            + params.loc[\"RTA\", \"beta_hat\"] * data[\"NRTA\"]\n        )\n</code></pre> <p>The ratio matrix used in the exact-hat algebra is:</p> <pre><code>T_ratio = (T_cf / T_bsln) ** (1 / (1 - sigma))\n</code></pre> <ol> <li> <p>Exact hat algebra solution</p> <p>Constructs:</p> <p>trade_BLN_mat (n\u00d7n): matrix of baseline bilateral trade (exporter \u00d7 importer).</p> <p>T_bsln and T_cf: baseline and counterfactual trade costs as (n\u00d7n).</p> <p>Computes:</p> <p>q   = row sums of trade_BLN_mat  # exports + domestic   phi = column sums / q   TI  = (phi - 1) * q              # trade imbalance   E   = q + TI   pi  = trade_BLN_mat / (1 $\\otimes$ E')   # expenditure shares</p> <p>Solves the system for the vector of \u201chats\u201d x using an external function:</p> <pre><code>sol = optimize.root(\n    solve_system_Ti,\n    x0,  # typically ones\n    args=(T_ratio, q, TI, pi, sigma),\n    method=\"df-sane\",\n)\nx = sol.x\n</code></pre> </li> </ol> <p>From x, obtains:   - hat_Y \u2013 output hats,   - hat_p \u2013 price hats,   - hat_PInd \u2013 counterfactual price indices,   - hat_pi \u2013 counterfactual expenditure shares,   - trade_c \u2013 counterfactual bilateral trade matrix.</p> <p>Basic consistency checks (check_q_c, check_E_c, check_WTI) are printed when verbose=True.</p> <p>Percentage changes and output</p> <p>Baseline and counterfactual aggregates:</p> <p>export_bsln and export_c \u2013 aggregate exports by country.</p> <p>Country-level percentage changes:</p> <ul> <li>x_per      = (x - 1) * 100</li> <li>exp_per    = (export_c / export_bsln - 1) * 100</li> <li>PInd_per   = (hat_PInd ** (1 / (1 - sigma)) - 1) * 100</li> <li>welfare_direct = (hat_Y / hat_PInd ** (1 / (1 - sigma)) - 1) * 100</li> </ul> <p>trade_c is reshaped back into a long DataFrame trade_FLL and merged with data for possible further analysis.</p> <p>Returns</p> <ul> <li> <p>summary (pandas.DataFrame) A country-level summary with one row per exporter country and the following columns:</p> </li> <li> <p>Country \u2013 country code (same ordering as exporters in the original data).</p> </li> <li> <p>Export% \u2013 percentage change in total exports (counterfactual vs. baseline).</p> </li> <li> <p>Real_Income% \u2013 percentage change in real income (direct welfare measure).</p> </li> <li> <p>Output% \u2013 percentage change in output.</p> </li> <li> <p>Cons_Price% \u2013 percentage change in the consumption price index.</p> </li> </ul> <p>Internally (within the function), the bilateral counterfactual trade flows are also merged back into the data DataFrame under the column trade_FLL, but this enriched DataFrame is not returned unless you modify the function to do so.</p> <p>Example</p> <pre><code>import pandas as pd\nfrom intrade.grav import struc_grav_cf  # adjust to your package structure\n\n# Example: EU\u2013UK trade-cost increase of 10%\n\n# 1. Load or construct a bilateral trade dataset\n# Required columns: exporter, importer, trade, LN_DIST, CNTG, LANG, BRDR, ...\ndata = pd.read_csv(\"bilateral_trade_example.csv\")\n\n# 2. Define baseline covariates and country groups\nvariables = [\"LN_DIST\", \"CNTG\", \"LANG\", \"BRDR\"]\n\nEU = [\"AUT\", \"BEL\", \"BGR\", \"HRV\", \"CYP\", \"CZE\", \"DNK\", \"EST\", \"FIN\",\n      \"FRA\", \"DEU\", \"GRC\", \"HUN\", \"IRL\", \"ITA\", \"LVA\", \"LTU\", \"LUX\",\n      \"MLT\", \"NLD\", \"POL\", \"PRT\", \"ROU\", \"SVK\", \"SVN\", \"ESP\", \"SWE\"]\n\ncountries1 = EU\ncountries2 = [\"GBR\"]\ncountries3 = []          # not used for selection = 1\nref_country = \"DEU\"      # importer FE reference\n\n# 3. Run the structural gravity + counterfactual analysis\nsummary = struc_grav_cf(\n    data=data,\n    variables=variables,\n    countries1=countries1,\n    countries2=countries2,\n    countries3=countries3,\n    ref_country=ref_country,\n    increase=10.0,   # 10% trade-cost increase\n    selection=1,\n    sigma=7.0,\n    verbose=True,\n)\n\n# 4. Inspect country-level percentage changes\nprint(summary.head())\n</code></pre>"},{"location":"struc_grav_incre/","title":"struc_grav_incre","text":""},{"location":"struc_grav_incre/#struc_grav_incre","title":"struc_grav_incre","text":"<p>Description</p> <p>Counterfactual: trade cost increase between country groups.</p> <p><code>struc_grav_incre</code> is a wrapper around <code>struc_grav_cf</code> for the scenario: One group of countries (countries1) increases its bilateral trade costs with another group (countries2) by a given percentage (increase).</p> <p>It estimates a structural gravity model (PPML), reconstructs the baseline, and solves the general equilibrium counterfactual using exact-hat algebra.</p> <p>Usage</p> <p><code>struc_grav_incre(     data,     variables,     countries1,     countries2,     ref_country,     increase,     sigma=7.0,     verbose=True, )</code></p> <p>Arguments</p> <ul> <li> <p><code>data</code> (DataFrame) : Bilateral trade data with gravity covariates (see <code>struc_grav_cf</code>).</p> </li> <li> <p><code>variables</code> (list[str]) : Names of baseline gravity covariates included in the PPML (e.g., <code>['LN_DIST', 'CNTG', 'LANG', 'BRDR']</code>).</p> </li> <li> <p><code>countries1</code>, <code>countries2</code> (list[str]) : Lists of country codes defining the two groups whose bilateral trade costs are changed.</p> </li> <li> <p><code>ref_country</code> (str) : Reference importer for fixed effects.</p> </li> <li> <p><code>increase</code> (float) : Percentage increase in trade costs between <code>countries1</code> and <code>countries2</code>.</p> </li> <li> <p><code>sigma</code> (float, default 7.0) : Elasticity of substitution.</p> </li> <li> <p><code>verbose</code> (bool, default True) : Print estimation output and consistency checks.</p> </li> </ul> <p>Value</p> <p>A DataFrame with one row per country and columns:</p> <ul> <li><code>\"Country\"</code></li> <li><code>\"Export%\"</code></li> <li><code>\"Real_Income%\"</code></li> <li><code>\"Output%\"</code></li> <li><code>\"Cons_Price%\"</code></li> </ul> <p>representing percentage changes between baseline and counterfactual.</p> <p>Example</p> <pre><code>EU = [\"AUT\",\"BEL\",\"DEU\",\"ESP\", ...]  # list of EU codes\n\nres_incre = struc_grav_incre(\n    data=df,\n    variables=['LN_DIST', 'CNTG', 'LANG', 'BRDR'],\n    countries1=['GBR'],\n    countries2=EU,\n    ref_country='DEU',\n    increase=10.0,\n    sigma=7.0,\n)\n</code></pre>"},{"location":"struc_grav_inout/","title":"struc_grav_inout","text":""},{"location":"struc_grav_inout/#struc_grav_inout","title":"struc_grav_inout","text":"<p>Counterfactual: entry or exit from a regional trade agreement (RTA)</p> <p>Description</p> <p>struc_grav_inout is a wrapper around struc_grav_cf for the scenario:</p> <p>One country enters or exits a regional trade agreement (RTA) formed by a group of countries (countries1).</p> <p>Usage</p> <p><code>struc_grav_inout(     data,     variables,     countries1,     countries2,     ref_country,     sigma=7.0,     verbose=True)</code></p> <p>Arguments</p> <p><code>countries1</code> (list[str]) : List of RTA member countries in the baseline.</p> <p><code>countries2</code> (list[str]) : List containing the country that enters or exits.</p> <p>Other arguments as in <code>struc_grav_incre</code>.</p> <p>Value</p> <p>Same as <code>struc_grav_incre</code>.</p> <p>Example</p> <pre><code># Example: Turkey enters an RTA currently formed by EU countries\n\n# Baseline RTA members (e.g. EU27 in the data)\nEU_RTA = [\n    \"AUT\",\"BEL\",\"BGR\",\"HRV\",\"CYP\",\"CZE\",\"DNK\",\"EST\",\"FIN\",\"FRA\",\n    \"DEU\",\"GRC\",\"HUN\",\"IRL\",\"ITA\",\"LVA\",\"LTU\",\"LUX\",\"MLT\",\"NLD\",\n    \"POL\",\"PRT\",\"ROU\",\"SVK\",\"SVN\",\"ESP\",\"SWE\"\n]\n\n# Country that enters or exits the RTA\nTURKEY = [\"TUR\"]\n\nres_inout = struc_grav_inout(\n    data=df,                               # bilateral trade + gravity covariates\n    variables=[\"LN_DIST\", \"CNTG\", \"LANG\", \"BRDR\"],\n    countries1=EU_RTA,                     # current RTA members in the baseline\n    countries2=TURKEY,                     # country that joins or leaves the RTA\n    ref_country=\"DEU\",                     # reference importer for fixed effects\n    sigma=7.0,\n    verbose=True,\n)\n\n# Interpretation:\n# - If \"TUR\" is NOT in EU_RTA, this scenario is \"Turkey joins the RTA\".\n# - If \"TUR\" IS already in EU_RTA, this scenario is \"Turkey exits the RTA\".\n\nprint(res_inout.head())\n</code></pre>"}]}